# 堆简介 🌳

堆是一种特殊的树状数据结构，每个节点都包含一个键值，且每个节点的键值都满足 **大于等于/小于等于** 其父节点的键值。

- **小根堆**：每个节点的键值都大于等于其父节点的键值
- **大根堆**：每个节点的键值都小于等于其父节点的键值

STL 中的 `priority_queue` 默认实现的是一个大根堆。

### 堆的核心操作 🛠️
- **插入元素**：向堆中添加一个新元素
- **查询最值**：获取堆中的最小/最大值
- **删除最值**：移除堆中的最小/最大值
- **合并堆**：将两个堆合并为一个
- **减小元素值**：降低某个元素的键值（某些堆支持）

部分高级堆结构（如可并堆）还支持高效的合并操作，甚至支持可持久化（对历史版本进行查询或操作）。

## 堆的分类 📊

| 操作                | 配对堆       | 二叉堆       | 左偏树       | 二项堆       | 斐波那契堆   |
|---------------------|--------------|--------------|--------------|--------------|--------------|
| 插入 (insert)       | $O(1)$       | $O(\log n)$  | $O(\log n)$  | $O(\log n)$  | $O(1)$       |
| 查询最小值 (find-min) | $O(1)$     | $O(1)$       | $O(1)$       | $O(1)$       | $O(1)$       |
| 删除最小值 (delete-min) | $O(\log n)$ | $O(\log n)$  | $O(\log n)$  | $O(\log n)$  | $O(\log n)$  |
| 合并 (merge)        | $O(1)$       | $O(n)$       | $O(\log n)$  | $O(\log n)$  | $O(1)$       |
| 减小元素值 (decrease-key) | $o(\log n)$ | $O(\log n)$  | $O(\log n)$  | $O(\log n)$  | $O(1)$       |
| 是否支持可持久化    | ❌           | ✅           | ✅           | ✅           | ❌           |

**注**：未特别说明时，堆 通常指二叉堆。


---


## 二叉堆 🔍

### 结构特性 🏗️

二叉堆是一种完全二叉树，每个节点存储一个元素（权值），并满足：

- **大根堆**：父节点权值 $\geq$ 子节点权值
- **小根堆**：父节点权值 $\leq$  子节点权值


### 数组实现 📏

完全二叉树可通过数组高效实现，节点下标关系：

- 父节点 $i$ 的左子节点：$2i$
- 父节点 $i$ 的右子节点：$2i+1$
- 子节点 $i$ 的父节点：$\lfloor i/2 \rfloor$

![二叉堆结构示意图](https://oi-wiki.org/ds/images/binary-heap-array.svg)

本文介绍大根堆的实现。


### 核心操作 💡


### 插入操作 🌟


插入操作是指向二叉堆中插入一个元素，要保证插入后也是一棵完全二叉树。

- 最简单的方法就是，最下一层最右边的叶子之后插入。
- 如果最下一层已满，就新增一层。

插入之后可能会不满足堆性质？

#### 向上调整 📚

如果这个结点的权值大于它父亲的权值，就交换，重复此过程直到不满足或者到根。


可以证明，插入之后向上调整后，没有其他结点会不满足堆性质。

向上调整的时间复杂度是 $O(\log n)$ 的。

![](https://oi-wiki.org/ds/images/binary_heap_insert.svg)


**具体实现**



- 插入操作 $\text{push(x)}$

    - 将新元素置于末尾：   $\text{a[++p] = x}; $
    - 调用 $\text{up(p)}$ 恢复堆性质。

**伪代码**


```cpp
function up(i):
  while i > 1 and a[i] > a[i/2]:
    swap(a[i], a[i/2])
    i = i / 2
return
```

- 每次交换向上跳一层，最多 $\lfloor \log_2 p\rfloor$ 层；
- 故向上调整时间复杂度为 $\displaystyle O(\log n)$。


**代码示例**


```cpp
void up(int p)
{
    while (p > 1 && a[p] > a[p / 2])
    {
        swap(a[p], a[p / 2]);
        p /= 2;
    }
}
void push(int x)
{
    a[++p] = x, up(p);
}
```


### 获取最值 🔍

堆顶即最大值，位于数组下标 $1$：$\quad \texttt{return a[1]};$

时间复杂度：$\displaystyle O(1)$。


注意：堆不支持随机访问第 $k$ 大，仅能取最值。


### 删除操作 📝

删除操作指删除堆中最大的元素，即删除根结点。

但是如果直接删除，则变成了两个堆，难以处理。

所以不妨考虑插入操作的逆过程，设法将根结点移到最后一个结点，然后直接删掉。

通常采用的方法是，把根结点和最后一个结点直接交换。

- 将堆顶与最后一元素交换：$\text{swap}(a[1],\,a[p])$，并令堆大小 $p\leftarrow p-1$。

- 对新堆顶执行 **向下调整** 以恢复堆性质。

#### 向下调整 📏

- 从根节点 $1$ 开始记为 $p$。
- 在该节点的左右儿子 $(2p,2p+1)$ 中找到一个最大的，与之交换。
- 重复该过程，直到底层。
- 向下调整的时间复杂度为 $O(\log n)$


**伪代码**


```cpp
function down(i):
  while 2 * i <=  p:                  # 有至少一个子节点
    j = 2 * i                        # 左子节点
    if j + 1 <= p and a[j + 1] > a[j]:
      j = j + 1                      # 取两子中较大者
    if a[i] < a[j]:
      swap(a[i], a[j])
      i = j                        # 继续向下
    else:
      break
  end while
```


**代码示例**


```cpp
void down(int i)
{
    while (i * 2 <= p)
    {
        int j = i * 2; // 获取左儿子编号
        if (j + 1 <= p && a[j + 1] > a[j]) j = j + 1; // 若右儿子存在且右儿子更大
        if (a[i] < a[j]) // 若小于较大的儿子就交换
        {
            swap(a[i], a[j]);
            i = j; // 令 i 等于 j 继续向下调整
        }
        else break; // 调整结束
    }
}
void pop() { a[1] = a[p--], down(1); }
```


### 增加某个点的权值 📏

很显然，直接修改后，向上调整一次即可，时间复杂度为 $O(\log n)$。





### 小根堆实现技巧 🎯


- 将原来判断 **子节点 $>$ 父节点** 改为 **子节点 $<$ 父节点**
- **取反** 技巧
    - 插入时将元素取 **负号**：$\text{push(-x)}$
    - 查询或删除最小值时，返回或输出结果再去掉负号：$\text{-top()}$。

## STL 的堆  📚


[学习priority_queue]()

## 例题

