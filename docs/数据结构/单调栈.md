## 🌲引入


何为单调栈？顾名思义，单调栈即满足单调性的栈结构。与单调队列相比，其只在一端进行进出。

为了描述方便，以下举例及伪代码以维护一个整数的单调递增栈为例。


## ⚙️ 过程


### 🔼 插入

将一个元素插入单调栈时，为了维护栈的单调性，需要在保证将该元素插入到栈顶后整个栈满足单调性的前提下弹出最少的元素。


例如，栈中自顶向下的元素为 $\{0,11,45,81\}$。



![](https://oi-wiki.org/ds/images/monotonous-stack-before.svg)


插入元素 $14$ 时为了保证单调性需要依次弹出元素 $0,11$，操作后栈变为 $\{14,45,81\}$。


![](https://oi-wiki.org/ds/images/monotonous-stack-after.svg)

用伪代码描述如下：


```cpp
insert x
while !stk.empty() && stk.top() < x // 先将小于 x 的全部出栈
    stk.pop()
sta.push(x)
```


### 🧩 应用

- **下一个更大元素（Next Greater Element）**  
    - 对每个位置 \(i\)，求其右侧第一个大于或等于 \(a_i\) 的下标 \(r_i\)，若不存在则 \(r_i=n+1\)。 
  
- **下一个更小元素（Next Smaller Element）**  
    - 对每个位置 \(i\)，求其右侧第一个小于或等于 \(a_i\) 的下标 \(r_i\)，若不存在则 \(r_i=n+1\)。 

- **前一个更大元素（Previous Greater Element）**
    - 对每个位置 \(i\)，求其左侧第一个大于或等于 \(a_i\) 的下标 \(l_i\)，若不存在则 \(l_i=0\)。 

- **前一个更小元素（Previous Smaller Element）**
    - 对每个位置 \(i\)，求其左侧第一个小于或等于 \(a_i\) 的下标 \(l_i\)，若不存在则 \(l_i=0\)。  




## 常见例题


### 📍 1. 下一个更大元素（Next Greater Element）


**题目：** 对长度为 \(n\) 的数组 \(a[1\ldots n]\)，求每个位置 \(i\) 右侧第一个比它大的元素下标 \(r_i\)，若不存在则 \(r_i=0\)。  


**❌ 暴力做法：**


```cpp
for (int i = 1; i <= n; i++) 
{
    for (int j = i+1; j <= n; j++) 
    {
        if (a[j] > a[i]) 
        {
            r[i] = j;
            break;
        }
    }
}
```

时间复杂度 \(O(n^2)\)，在最坏情况下会做 \(\Theta(n^2)\) 次比较。


**✅ 单调栈优化：**

注意到：当我们扫描到某个大元素 $a[k]$ 时，位于它之前且比它小的一段下标序列 $i_1<i_2<\cdots<i_m<k$ 满足：

\[
    a[i_1]>a[i_2]>\cdots>a[i_m]<a[k].
\]

那么 $a[k]$ 就是它们所有人的 **下一个更大元素**，可一次性赋值  $r_{i_1}=r_{i_2}=\cdots=r_{i_m}=k$。  
 
这启发我们用 **单调栈** 来批量解决这些查询。



**维护策略：**

- 维护一个 **存下标** 的栈 $\text{stk}$，保证从栈顶到栈底对应值 $\downarrow$（**单调递减**）
- 扫描 $i=1$ 到 $n$：
    - 当栈非空且 $a[\text{stk.top()}] < a[i]$ 时：
        - 弹出栈顶下标 $j=\text{stk.top()}$，设 $r_j=i$
    - 重复上述弹出，直至栈空或顶部值 $\ge a[i]$
    - 最后将 $i$ 入栈，等待它的 **下一个更大元素**


- 每个下标最多进出栈一次，时间复杂度 $O(n)$。
- 推荐用 $\text{vector}$ 或数组 模拟栈，性能优于 $\text{stack}$。

```cpp
vector<int> stk, r(n + 1, 0);
for (int i = 1; i <= n; i++) 
{
    while (!stk.empty() && a[stk.back()] < a[i]) 
    {
        r[stk.back()] = i;
        stk.pop_back();
    }
    stk.push_back(i);
}
```


### 📍 2. 下一个更小元素 与 上一个更小元素



**题目：** 给定数组 $a[1\ldots n]$，需同时求得对每个位置 $i$： 

$$\begin{aligned}
&L_i = \max\{j<i \mid a[j]<a[i]\}\\
&R_i = \min\{j>i \mid a[j]<a[i]\}
\end{aligned}$$

若不存在则分别令 $L_i=0,\,R_i=n+1$。 



**思路：单调栈求右侧第一个更小**

从左向右一次扫描，维护 **单调递增** 的下标栈（栈顶 $\to $栈底对应值递增）

- 遍历 $i=1\ldots n$，令初始 $R_i=n+1$
- 当栈非空且 $a[\text{stk.back()}] > a[i]$ 时:
    - 弹出 $j=\text{stk.back()}$，设 $R_j = i$
- 将 $i$ 入栈，继续扫描。

每个下标最多入/出栈一次，总体 $O(n)$。



**思路：单调栈求左侧第一个更小**

从右向左一次扫描，维护 **单调递增** 的下标栈（栈顶 $\to $栈底对应值递增）

- 遍历 $i=n\ldots 1$，令初始 $L_i=0$
- 当栈非空且 $a[\text{stk.back()}] > a[i]$ 时:
    - 弹出 $j=\text{stk.back()}$，设 $L_j = i$
- 将 $i$ 入栈，继续扫描。

每个下标最多入/出栈一次，总体 $O(n)$。


```cpp
vector<int> L(n + 1,0), R(n + 1,n + 1), stk;
for (int i = 1; i <= n; i++) 
{
    while (!stk.empty() && a[stk.back()] > a[i]) 
    {
        R[stk.back()] = i;
        stk.pop_back();
    }
    stk.push_back(i);
}
stk.clear();
for (int i = n; i >= 1; i--) 
{
    while (!stk.empty() && a[stk.back()] > a[i]) 
    {
        L[stk.back()] = i;
        stk.pop_back();
    }
    stk.push_back(i);
}
```


### 📐 例题三：直方图中最大矩形面积


**题目：** 给定高度数组 $h[1\ldots n]$，求最大矩形面积。


**思路：**

- 对每个柱子 $i$ 作为 **最低高度** 进行枚举
- 向左找到第一个高度 $< h_i$ 的位置 $L_i$
- 向右找到第一个高度 $< h_i$ 的位置 $R_i$
- 以柱子 $i$ 为高，最大宽度为 $(R_i - L_i - 1)$，面积

$$
\text{Area}_i = h_i \times (R_i - L_i - 1)
$$


最终答案 $\max_i \text{Area}_i$


### 🧮 例题四：[COCI 2010/2011 #3] DIFERENCIJA

给定数组 $a[1\ldots n]$，计算

$$
\sum_{1\le i\le j\le n}
\bigl(\max_{i\le k\le j}a_k \,-\, \min_{i\le k\le j}a_k\bigr).
$$

等价于两部分：  

$$
    S_{\max} \;-\; S_{\min},
    \quad
    S_{\max}=\sum_{i=1}^n\sum_{j=i}^n\max_{i\le k\le j}a_k.
$$
  
本处只讨论如何高效计算 $S_{\max}$。


**直观思路：**


- 枚举区间：$O(n^2)$ 无法承受。
    - 枚举区间的同时还需要求区间的 $\max$。
- 复杂度：$O(n^3)$

**转变思路：枚举 区间最大值**

对于每个位置 $i$，统计有多少子区间以 $a_i$ 为最大值，记作 $\mathit{cnt}_i$。  

$$
S_{\max} = \sum_{i=1}^n \bigl(\mathit{cnt}_i \times a_i\bigr).
$$

关键：高效求出 $\mathit{cnt}_i$。


若以 $a_i$ 为 **严格最大值**，则子区间左右边界 $x\le i\le y$ 必须满足：


$$
\max_{x\le k<i} a_k < a_i,
    \quad
    \max_{i<k\le y} a_k \le a_i.
$$

设

$$
L_i = \max\{\,j<i \mid a_j>a_i\},\quad
    R_i = \min\{\,j>i \mid a_j\ge a_i\}
$$



则可选左端点数 $(i-L_i)$，右端点数 $(R_i-i)$。

$$
\mathit{cnt}_i = (i - L_i)\,(R_i - i)
$$

> 为何左侧是 $a_j>a_i$，右侧确是 $a_j\geq a_i$?
> 这里主要是避免重复计算，例如：`[7, 5, 7, 5]`。可以自己体会一下为何需要右侧保证 $a_j\geq a_i$。

**代码实现**

```cpp
for (int i = 1; i <= n; i++) 
{
    cin >> a[i];
    l[i] = 0, r[i] = n + 1;
}
for (int i = 1; i <= n; i++) 
{
    while (top && a[i] >= a[stk[top]]) 
    {
        r[stk[top]] = i; // 对于栈顶来说，右侧第一个大于或等于自己的就是 a[i]
        top--;
    }
    l[i] = stk[top]; // 小于或等于 a[i] 的都出栈了，因此栈顶就是位置 i 左侧第一个大于 a[i] 的位置
    stk[++top] = i;
}
```