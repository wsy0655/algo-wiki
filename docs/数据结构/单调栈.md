## 🌲 引入

何为单调栈？顾名思义，单调栈即满足单调性的栈结构。与单调队列相比，其只在一端进行进出。

为了描述方便，以下举例及伪代码以维护一个整数的单调递增栈为例。

---

## ⚙️ 单调栈操作过程

### 🔼 插入元素

将一个元素插入单调栈时，为了维护栈的单调性，需要在保证将该元素插入到栈顶后整个栈满足单调性的前提下弹出最少的元素。

例如，栈中自顶向下的元素为 \${0,11,45,81}\$。

![](https://oi-wiki.org/ds/images/monotonous-stack-before.svg)

插入元素 \$14\$ 时为了保证单调性需要依次弹出元素 \$0,11\$，操作后栈变为 \${14,45,81}\$。

![](https://oi-wiki.org/ds/images/monotonous-stack-after.svg)

伪代码如下：

```cpp
insert x
while !stk.empty() && stk.top() < x // 先将小于 x 的全部出栈
    stk.pop()
sta.push(x)
```

---

## 🧩 单调栈应用

**📘 下一个更大元素（Next Greater Element）**

* 对每个位置 $i$，求其右侧第一个大于或等于 $a_i$ 的下标 $r_i$，若不存在则 $r_i=n+1$。

**📙 下一个更小元素（Next Smaller Element）**

* 对每个位置 $i$，求其右侧第一个小于或等于 $a_i$ 的下标 $r_i$，若不存在则 $r_i=n+1$。

**📗 前一个更大元素（Previous Greater Element）**

* 对每个位置 $i$，求其左侧第一个大于或等于 $a_i$ 的下标 $l_i$，若不存在则 $l_i=0$。

**📕 前一个更小元素（Previous Smaller Element）**

* 对每个位置 $i$，求其左侧第一个小于或等于 $a_i$ 的下标 $l_i$，若不存在则 $l_i=0$。

---

## 🎯 常见例题

### 📍 1. 下一个更大元素（Next Greater Element）

**题目：** 对长度为 \$n\$ 的数组 \$a\[1\ldots n]\$，求每个位置 \$i\$ 右侧第一个比它大的元素下标 \$r\_i\$，若不存在则 \$r\_i=n+1\$。

**❌ 暴力做法：**

```cpp
for (int i = 1; i <= n; i++) r[i] = n + 1;
for (int i = 1; i <= n; i++)
{
    for (int j = i+1; j <= n; j++)
    {
        if (a[j] > a[i])
        {
            r[i] = j;
            break;
        }
    }
}
```

时间复杂度 $O(n^2)$，最坏情况下会有 $\Theta(n^2)$ 次比较。

**✅ 单调栈优化：**

注意到：当我们扫描到某个大元素 $a[k]$ 时，位于它之前且比它小的一段下标序列 $i_1<i_2<\cdots<i_m<k$ 满足：

\[
    a[i_1]>a[i_2]>\cdots>a[i_m]<a[k].
\]

那么 $a[k]$ 就是它们所有人的 **下一个更大元素**，可一次性赋值  $r_{i_1}=r_{i_2}=\cdots=r_{i_m}=k$。  
 
这启发我们用 **单调栈** 来批量解决这些查询。



**维护策略：**

- 维护一个 **存下标** 的栈 $\text{stk}$，保证从栈顶到栈底对应值 $\downarrow$（**单调递减**）
- 扫描 $i=1$ 到 $n$：
    - 当栈非空且 $a[\text{stk.top()}] < a[i]$ 时：
        - 弹出栈顶下标 $j=\text{stk.top()}$，设 $r_j=i$
    - 重复上述弹出，直至栈空或顶部值 $\ge a[i]$
    - 最后将 $i$ 入栈，等待它的 **下一个更大元素**

**算法流程：**

**stack** 实现

```cpp
for (int i = 1; i <= n; i++) r[i] = n + 1;
stack<int> stk;
for (int i = 1; i <= n; i++)
{
    while (!stk.empty() && a[stk.top()] < a[i])
    {
        r[stk.top()] = i;
        stk.pop();
    }
    stk.push(i);
}
```

**数组模拟栈** 实现

```cpp
for (int i = 1; i <= n; i++) r[i] = n + 1;
int top = 0; // 维护栈顶
for (int i = 1; i <= n; i++)
{
    while (top && a[stk[top]] < a[i])
    {
        r[stk[top]] = i;
        top--;
    }
    stk[++top] = i;
}
```


**vector** 充当栈

```cpp
for (int i = 1; i <= n; i++) r[i] = n + 1;
vector<int> stk;
for (int i = 1; i <= n; i++)
{
    while (!stk.empty() && a[stk.top()] < a[i])
    {
        r[stk.top()] = i;
        stk.pop_top();
    }
    stk.push_back(i);
}
```

每个下标最多进出栈一次，时间复杂度为 $O(n)$。

**同理可得上一个更大的求法**

```cpp
for (int i = 1; i <= n; i++) l[i] = 0;
int top = 0;
for (int i = n; i >= 1; i--)
{
    while (top && a[i] > a[stk[top]])
    {
        l[stk[top]] = i;
        top--;
    }
    stk[++top] = i;
}
```

---

### 📍 2. 下一个更小元素 与 上一个更小元素

**题目：** 给定数组 $a[1\ldots n]$，对每个位置 $i$ 求：

$$\begin{aligned}
&L_i = \max\{j<i \mid a[j]<a[i]\}\\
&R_i = \min\{j>i \mid a[j]<a[i]\}
\end{aligned}$$

若不存在则分别令 $L_i=0,\,R_i=n+1$。



**➤ 求右侧第一个更小**

从左向右一次扫描，维护 **单调递增** 的下标栈（栈顶 $\to $ 栈底对应值递增）

- 遍历 $i=1\ldots n$，令初始 $R_i=n+1$
- 当栈非空且 $a[\text{stk.top()}] > a[i]$ 时:
    - 弹出 $j=\text{stk.top()}$，设 $R_j = i$
- 将 $i$ 入栈，继续扫描。

每个下标最多入/出栈一次，总体 $O(n)$。


```cpp
for (int i = 1; i <= n; i++) 
    l[i] = 0, r[i] = n + 1;
top = 0;
for (int i = 1; i <= n; i++)
{
    while (top && a[stk[top]] > a[i])
    {
        r[stk[top]] = i;
        top--;
    }
    stk[++top] = i;
}
```

**➤ 求左侧第一个更小**

从右向左一次扫描，维护 **单调递增** 的下标栈（栈顶 $\to $ 栈底对应值递增）

- 遍历 $i=n\ldots 1$，令初始 $l_i=0$
- 当栈非空且 $a[\text{stk.top()}] > a[i]$ 时:
    - 弹出 $j=\text{stk.top()}$，设 $l_j = i$
- 将 $i$ 入栈，继续扫描。

每个下标最多入/出栈一次，总体 $O(n)$。

```cpp
top = 0; // 清空栈
for (int i = n; i >= 1; i--)
{
    while (top && a[stk[top]] > a[i])
    {
        l[stk[top]] = i;
        top--;
    }
    stk[++top] = i;
}
```

---

### 📐 3. 直方图中最大矩形面积

**题目：** 给定高度数组 $h[1\ldots n]$，求最大矩形面积。

**✅ 思路：**

- 对每个柱子 $i$ 作为 **最低高度** 枚举
- 找到左右两边第一个高度 $< h_i$ 的位置 $L_i, R_i$
- 计算面积 $= h_i \times (R_i - L_i - 1)$

最终答案为所有柱子的最大面积：

$$
\text{Area}_i = \max(h_i \times (R_i - L_i - 1))
$$

---

### 🧮 4. [COCI 2010/2011 #3] DIFERENCIJA

给定数组 $a[1\ldots n]$，计算

计算：

$$
\sum_{1\le i\le j\le n}
\bigl(\max_{i\le k\le j}a_k \,-\, \min_{i\le k\le j}a_k\bigr).
$$

**🧠 等价于：**

$$
    S_{\max} \;-\; S_{\min},
    \quad
    S_{\max}=\sum_{i=1}^n\sum_{j=i}^n\max_{i\le k\le j}a_k.
$$

我们只讨论 $S_{\max}$ 的计算。

**❌ 暴力思路：**


- 枚举区间：$O(n^2)$ 无法承受。
    - 枚举区间的同时还需要求区间的 $\max$。
- 复杂度：$O(n^3)$

**✅ 贡献法：枚举最大值**

对于每个位置 $i$，统计有多少子区间以 $a_i$ 为最大值，记作 $\mathit{cnt}_i$。  这就是贡献法的体现，计算每个数值对答案的贡献。

$$
S_{\max} = \sum_{i=1}^n \bigl(\mathit{cnt}_i \times a_i\bigr).
$$

关键：高效求出 $\mathit{cnt}_i$。


若以 $a_i$ 为 **严格最大值**，则子区间左右边界 $x\le i\le y$ 必须满足：


$$
\max_{x\le k<i} a_k < a_i,
    \quad
    \max_{i<k\le y} a_k \le a_i.
$$

设

$$
L_i = \max\{\,j<i \mid a_j>a_i\},\quad
R_i = \min\{\,j>i \mid a_j\ge a_i\}
$$

可选左端点数为 $(i - L_i)$，右端点数为 $(R_i - i)$：

$$
\mathit{cnt}_i = (i - L_i)\times (R_i - i)
$$

> 🧩 为何左侧是 $a_j>a_i$，右侧是 $a_j\geq a_i$?
> 为避免重复计算，例如 `[7, 5, 7, 5]`，可以自行体会。

**📌 代码实现：**

```cpp
for (int i = 1; i <= n; i++) 
{
    cin >> a[i];
    l[i] = 0, r[i] = n + 1;
}
for (int i = 1; i <= n; i++) 
{
    while (top && a[i] >= a[stk[top]]) 
    {
        r[stk[top]] = i; // 对于栈顶来说，右侧第一个大于或等于自己的就是 a[i]
        top--;
    }
    l[i] = stk[top]; // 小于或等于 a[i] 的都出栈了，因此栈顶就是位置 i 左侧第一个大于 a[i] 的位置
    stk[++top] = i;
}
long long mx = 0;
for (int i = 1; i <= n; i++)
{
    mx += 1ll * a[i] * (i - l[i]) * (r[i] - i); // 计算每个 a[i] 对答案的贡献
}
```

---



