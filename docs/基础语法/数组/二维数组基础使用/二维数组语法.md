

## 定义

二维数组是数组的数组，本质上是一个矩阵结构。

```cpp
int a[100][100]; // 定义一个最多 100 行 100 列的二维整型数组
```

### 初始化

可以使用以下方式对二维数组进行初始化：

```cpp
int a[2][3] = 
{
    {1, 2, 3},
    {4, 5, 6}
};
```

或者简写为：

```cpp
int a[2][3] = {1, 2, 3, 4, 5, 6};
```

未初始化的元素会自动填充为 $0$：

```cpp
int a[3][3] = {{1}, {2}, {3}};
// 实际内容为：
// 1 0 0
// 2 0 0
// 3 0 0
```

### 访问元素

使用下标 `a[i][j]` 访问第 `i` 行第 `j` 列的元素（下标从 $0$ 开始）：

```cpp
cout << a[1][2]; // 输出第 1 行第 2 列的值
```

### 常见格式：读入 $n$ 行 $m$ 列

假设输入一个 $n$ 行 $m$ 列的矩阵：

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[105][105];
int main() 
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) 
    {
        for (int j = 1; j <= m; j++) 
        {
            cin >> a[i][j];
        }
    }
    return 0;
}
```

同样地，你可以定义三维、四维，以及更高维的数组。

___

## 基础例题

### 题目一：二维数组行的遍历。

题意：给定一个 $n$ 行 $m$ 列的二维数组 $a$，同时给定一个数字 $x$，请你输出第 $x$ 行的所有元素。以及求出第 $x$ 行所有元素的和。$1\leq n,m\leq 100,1\leq x\leq n,1\leq a_{i,j}\leq 10^9$


**思路**

第 $x$ 行的元素分别为：$a[x][1],a[x][2],\ldots,a[x][m]$。

可以看出只有列再变化，因此遍历列 $j$ 其中 $j\in [1,m]$。输出所有元素并累加求和即可，注意根据数据范围需要 `long long`。


```cpp
long long sum = 0;
for (int i = 1; i <= m; i++)
{
    cout << a[x][i] << " ";
    sum += a[x][i];
}
cout << "\n" << sum;
```


___


### 题目二：二维数组列的遍历

题意：给定一个 $n$ 行 $m$ 列的二维数组 $a$，同时给定一个数字 $y$，请你输出第 $y$ 列的所有元素。以及求出第 $y$ 列所有元素的和。$1\leq n,m\leq 100,1\leq y\leq m,1\leq a_{i,j}\leq 10^9$


**思路**

第 $y$ 列的元素分别为：$a[1][y],a[2][y],\ldots,a[n][y]$。

可以看出只有行再变化，因此遍历行 $i$ 其中 $i\in [1,n]$。输出所有元素并累加求和即可，注意根据数据范围需要 `long long`。


```cpp
long long sum = 0;
for (int i = 1; i <= n; i++)
{
    cout << a[i][y] << " ";
    sum += a[i][y];
}
cout << "\n" << sum;
```


___



### 题目三：计算矩阵边缘元素之和

题意：输入一个整数矩阵，计算位于矩阵边缘的元素之和。所谓矩阵边缘的元素，就是第一行和最后一行的元素以及第一列和最后一列的元素。$1 \le m,n \le 100$。保证答案在 `int` 范围内。


**思路**

答案可以通过遍历所有位置，然后使用 `if` 语句判断位置 $(i,j)$ 是否在边缘来实现。

如果一个位置 $(i,j)$ 在边缘上，则满足以下条件之一：

- $i = 1$ 或 $i = n$（第一行或最后一行）
- $j = 1$ 或 $j = m$（第一列或最后一列）

```cpp
for (int i = 1; i <= n; i++)
{
    for (int j = 1; j <= m; j++)
    {
        if (i == 1 || i == n || j == 1 || j == m) // 判断是否在边缘
        {
            sum += a[i][j]; // 累加边缘元素
        }
    }
}
```


___


### 题目四：矩阵转置


题意：输入一个 $n$ 行 $m$ 列的矩阵 $A$，输出它的转置 $A^T$。转置就是将矩阵的行和列互换。$1 \leq n,m \leq 100$。


**思路**

转置矩阵 $A^T$ 的第 $i$ 行第 $j$ 列元素等于原矩阵 $A$ 的第 $j$ 行第 $i$ 列元素，即 $A^T[i][j] = A[j][i]$。

具体实现可以借助一个新的二维数组 `b` 来存储转置后的结果。

- 首先输入原矩阵 $A$。
- 然后遍历原矩阵，将每个元素放到转置矩阵的对应位置。
- 最后输出转置矩阵。

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[105][105], b[105][105];
int main() 
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) 
    {
        for (int j = 1; j <= m; j++) 
        {
            cin >> a[i][j];
        }
    }
    for (int j = 1; j <= m; j++) 
    {
        for (int i = 1; i <= n; i++) 
        {
            b[j][i] = a[i][j];
        }
    }
    for (int i = 1; i <= m; i++) 
    {
        for (int j = 1; j <= n; j++) 
        {
            cout << b[i][j] << " ";
        }
        cout << "\n";
    }
    return 0;
}
```

___