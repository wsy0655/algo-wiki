

## 1. 题目分析

- 给定一支队伍的提交记录，共有 $n$ 条，每条包含题目编号 `pid_i` 和状态 `state_i`（0 表示未通过，1 表示通过）；
- 题目数量为 $p$；
- 我们需要统计这支队伍最终通过了多少道不同的题目；
- 只有在第一次成功通过某题时，提交才是有效，之后即使该题再次通过，也不算新的通过。

---

## 2. 解题思路

- 使用一个布尔数组（或整型数组）`passed` 长度为 $p$，用于标记每道题是否已经被通过；
- 初始化所有题目状态为未通过（`false`）；
- 逐条遍历提交记录：
  - 如果当前提交状态为通过(`state_i = 1`)且该题还未通过过，则将对应位置标记为通过(`true`)；
- 最终统计 `passed` 中为 `true` 的题目个数即为答案。

---

## 3. 处理流程

1. 读入 $n, p$；
2. 初始化 `passed` 数组，长度 $p$，全部为 `false`；
3. 对 $n$ 条提交依次读取 `pid_i, state_i`：
   - 若 `state_i == 1` 且 `passed[pid_i - 1] == false`，则将 `passed[pid_i - 1] = true`；
4. 统计并输出 `passed` 数组中 `true` 的数量。

---

## 4. 实现步骤

- 定义 `bool passed[p] = {false}`；
- 遍历所有提交：
  - 如果 `state == 1` 并且对应题目未通过，标记通过；
- 最后计算通过题目数量。

---

## 5. 复杂度分析

- 时间复杂度：$O(n)$，只遍历提交列表一次；
- 空间复杂度：$O(p)$，用于存储题目通过状态。

---

## 6. 总结

- 利用布尔数组快速判断和更新题目通过状态；
- 只需关注第一次成功提交，避免重复计数；
- 简单高效，适合 $n,p \leq 1000$ 规模。
