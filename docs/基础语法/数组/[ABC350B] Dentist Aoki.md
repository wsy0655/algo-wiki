

## 1. 题目分析

- 初始时，编号为 $1$ 到 $N$ 的洞中各有一颗牙齿，总计 $N$ 颗牙齿；
- 每次治疗操作针对一个洞：
  - 如果该洞中有牙齿，则移除牙齿（该洞变空）；
  - 如果该洞为空，则长出一颗牙齿；
- 需要根据 $Q$ 次操作后，计算剩余牙齿的数量。

---

## 2. 解题思路

- 使用一个长度为 $N$ 的布尔数组 `hasTooth` 来表示每个洞是否有牙齿；
- 初始化时，所有洞都有牙齿，即所有元素为 `true`；
- 遍历治疗操作序列 $T_i$：
  - 若 `hasTooth[T_i]` 是 `true`，置为 `false`（移除牙齿）；
  - 否则置为 `true`（长出牙齿）；
- 最后统计 `hasTooth` 中为 `true` 的个数，即剩余牙齿数量。

---

## 3. 处理流程

1. 读入 $N, Q$；
2. 初始化长度为 $N$ 的布尔数组 `hasTooth`，全部置 `true`；
3. 读取 $Q$ 个治疗洞编号 $T_i$；
4. 对每个 $T_i$，切换 `hasTooth[T_i]` 的状态；
5. 遍历 `hasTooth` 统计为 `true` 的数量；
6. 输出该数量。

---

## 4. 实现步骤

- 定义布尔数组 `hasTooth[N]`，全部赋值为 `true`；
- 遍历输入的 $Q$ 次治疗操作：
  - `hasTooth[T_i] = !hasTooth[T_i]`（切换状态）；
- 遍历数组计数，输出计数结果。

---

## 5. 复杂度分析

- 时间复杂度：$O(N + Q)$，初始化和遍历操作均为线性；
- 空间复杂度：$O(N)$，用于存储每个洞的状态。

---

## 6. 总结

- 利用布尔状态表示洞的牙齿是否存在；
- 每次操作直接切换对应状态；
- 最终统计 `true` 的数量即为剩余牙齿数。
