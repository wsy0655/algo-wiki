

## 1. 题目分析

- 有 $m$ 棵树和 $m-1$ 片草坪，排列为：树1，草坪1，树2，草坪2，…，树$m$；
- 两种施工操作破坏区间内的绿化：
  - 类型 1：破坏第 $l$ 棵树和第 $r$ 棵树之间（不含 $l,r$）的所有绿化，即破坏树 $(l+1)$ 到 $(r-1)$ 和草坪 $l$ 到 $r-1$；
  - 类型 2：破坏第 $l$ 棵树和第 $r$ 棵树之间（包含 $l,r$）的所有绿化，即破坏树 $l$ 到 $r$ 和草坪 $l$ 到 $r-1$；
- 施工后统计剩余未被破坏的树和草坪数量。

---

## 2. 解题思路

- 维护两个数组：
  - `tree[1..m]` 标记每棵树是否被破坏（`False` 表示存活，`True` 表示被破坏）；
  - `grass[1..m-1]` 标记每片草坪是否被破坏；
- 对每次施工，根据类型更新 `tree` 和 `grass` 的状态；
- 最后统计 `False` 的个数即为剩余的树和草坪数。

---

## 3. 处理流程

1. 初始化 `tree` 和 `grass` 数组，全部标记为 `False`；
2. 遍历每次施工：
   - 若类型为 1：
     - 对树：标记 `tree[l+1 .. r-1]` 为 `True`（若区间非空）；
     - 对草坪：标记 `grass[l .. r-1]` 为 `True`；
   - 若类型为 2：
     - 对树：标记 `tree[l .. r]` 为 `True`；
     - 对草坪：标记 `grass[l .. r-1]` 为 `True`；
3. 统计 `tree` 中 `False` 的数量为剩余树数，统计 `grass` 中 `False` 的数量为剩余草坪数；
4. 输出两个结果。

---

## 4. 实现步骤

- 读入 $m,n$；
- 初始化 `tree = [False]*m`，`grass = [False]*(m-1)`；
- 循环读入每次施工类型和区间 $l,r$：
  - 根据类型更新对应区间的 `tree` 和 `grass` 状态；
- 统计并输出存活树和草坪数量。

---

## 5. 复杂度分析

- 每次施工最多修改 $O(m)$ 个元素，最多 $n$ 次操作；
- 时间复杂度为 $O(m \times n)$，对于 $m,n \leq 5000$ 可接受；
- 空间复杂度为 $O(m)$。

---

## 6. 总结

- 题目考察区间标记和状态维护；
- 注意边界处理和区间是否包含端点的区别；
- 通过简单数组标记和统计实现，代码逻辑直观。
