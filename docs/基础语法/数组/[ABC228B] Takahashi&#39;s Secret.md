

## 1. 题目分析

高桥有 $N$ 个朋友，每个朋友 $i$ 会把秘密告诉另一个指定的朋友 $A_i$（只会告诉一个人）。  
当某个朋友得知秘密后，他会立即传播给他的目标朋友，前提是对方还不知道。

一开始只有朋友 $X$ 知道秘密。我们要统计最终有多少个朋友会知道这个秘密。

从传播方式看，这是一个**单向的传递链**，每个人只会告诉一个人，因此结构类似于链或图中的路径。

---

## 2. 解题思路

可以把这个传播过程看作是**从节点 $X$ 开始的一条路径**，每次跳到 $A_i$ 指向的人，直到遇到已经访问过的节点为止。

为了避免重复传播，我们使用一个**布尔数组 `visited`** 标记哪些人已经知道秘密。

从 `X` 开始，一步一步跳到 `A[x]`，每跳一步，就标记该人已经知道秘密，直到跳到一个已经被标记的人为止。

---

## 3. 处理流程

1. 输入 $N$ 和 $X$；
2. 输入数组 $A$（长度 $N$）；
3. 定义全局布尔数组 `visited[100005]`，初始为 `false`；
4. 从朋友 $X$ 开始，模拟传播过程：
   - 只要当前朋友没有被访问过，就标记为已知；
   - 移动到 `A[x]`，继续传播；
   - 一旦遇到已访问的朋友，停止；
5. 最后统计 `visited` 中被标记为 `true` 的总人数，即为答案。

---

## 4. 实现步骤

1. 读入 $N$ 和 $X$；
2. 用数组 `A[100005]` 存每个人要告诉的朋友编号；
3. 定义布尔数组 `visited[100005]` 初始化为全 `false`；
4. 使用变量 `cur = X` 表示当前传播到的人；
5. 使用 `while(true)` 循环模拟传播过程：
   - 如果 `visited[cur] == true`，跳出；
   - 否则标记 `visited[cur] = true`；
   - 然后更新 `cur = A[cur]` 跳到下一个人；
6. 遍历 `visited` 数组，统计为 `true` 的个数。

---

## 5. 复杂度分析

- **时间复杂度**：$O(N)$，每个朋友最多只被访问一次；
- **空间复杂度**：$O(N)$，用于存储数组 `A` 和访问标记数组 `visited`。

---

## 6. 总结

- 本题可以建模为从某个起点出发的一条链式传播路径；
- 用布尔数组记录访问状态，防止重复；
- 模拟传播过程，直到遇到环或终点；
- 实现简单，效率高，适合用 `while` 循环处理。
