

## 1. 题目分析

- 小 Z 初始有 $x$ 枚金币，面对 $n$ 个卡包；
- 每个卡包有 5 张卡牌，面额分别在 1~5 之间；
- 小 Z 对每个卡包，只能买一张卡牌，且必须是自己能买得起的面额最大的卡牌；
- 买不起任何卡牌时跳过该卡包；
- 计算最终小 Z 各面额卡牌数量和剩余金币。

---

## 2. 解题思路

- 对每个卡包，找到小 Z 能买得起的卡牌中面额最大的一个；
- 若找到则购买（计数加1，金币减少相应面额）；
- 否则不买，继续下一个卡包；
- 最后统计各面额卡牌数量和金币剩余。

---

## 3. 处理流程

1. 读入初始金币 $x$ 和卡包数量 $n$；
2. 初始化一个长度为 5 的数组 `count` 用于统计面额为 1~5 的卡牌数量，初始全0；
3. 对每个卡包，读取 5 张卡牌面额；
4. 对这 5 张卡牌中能买得起的牌，找到最大面额；
5. 如果存在可买的卡牌，则：
   - `count[maxFace - 1] += 1`；
   - `x -= maxFace`；
6. 最后输出 `count` 和剩余金币 `x`。

---

## 4. 实现步骤

- 使用循环读取 $n$ 个卡包数据；
- 对每个卡包，用一个循环遍历五张卡牌面额，记录能买得起的最大面额；
- 购买时更新统计和金币；
- 输出统计结果和剩余金币。

---

## 5. 复杂度分析

- 时间复杂度：$O(n)$，每个卡包遍历固定 5 张卡牌；
- 空间复杂度：$O(1)$，统计数组长度固定为 5。

---

## 6. 总结

- 题目本质为贪心问题，每次选最大可买面额卡牌；
- 代码实现简洁高效，适合大数据规模；
- 注意购买后金币减少，不能买超过金币数的卡牌。
