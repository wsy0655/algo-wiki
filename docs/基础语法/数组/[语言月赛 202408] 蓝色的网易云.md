### 背景

题目中有 $n$ 首歌曲，分成 $m$ 类，每类歌曲数量相同（$n$ 是 $m$ 的倍数）。我们需要安排歌曲顺序，保证相邻歌曲题材不相同。

---

### 为什么用二维数组？

- 每个题材有固定数量的歌曲，数量相同。
- 可以用二维数组（列表的列表）来存储每个题材的所有歌曲编号。
  - 行数为题材数量 $m$。
  - 列数为每个题材的歌曲数量 $k = n/m$。

---

### 实现步骤

1. **初始化二维数组**  
   - 创建一个大小为 $m \times k$ 的二维数组，或者 $m$ 个列表，每个列表用来存放该题材的歌曲编号。

2. **分组歌曲编号**  
   - 遍历所有歌曲编号 $i$，其题材为 $c_i$。
   - 将歌曲编号 $i$ 加入二维数组对应的行（题材编号减1作为索引）中的下一个空位。

3. **轮流输出**  
   - 题材数量为 $m$，每个题材有 $k$ 首歌。
   - 按列遍历二维数组：
     - 外层循环 $j$ 从 $0$ 到 $k-1$（歌曲在题材列表中的位置）
     - 内层循环 $i$ 从 $0$ 到 $m-1$（题材编号）
   - 每次输出二维数组中 $arr[i][j]$ 的歌曲编号。
   - 这样轮流从每个题材取一首歌，保证相邻歌曲题材不同。

---

### 具体示例

假设 $n=6, m=3$，分配如下：

| 题材编号 | 歌曲编号（填入二维数组）     |
|---------|----------------------------|
| 1       | arr[0] = [1, 2]            |
| 2       | arr[1] = [3, 4]            |
| 3       | arr[2] = [5, 6]            |

输出顺序：

- 第一轮（$j=0$）：输出 arr[0][0]=1，arr[1][0]=3，arr[2][0]=5
- 第二轮（$j=1$）：输出 arr[0][1]=2，arr[1][1]=4，arr[2][1]=6

得到的播放序列是：1 3 5 2 4 6，满足相邻题材不同。

---

### 小结

- 二维数组直观管理每个题材的所有歌曲编号。
- 轮流取歌（按列遍历）有效避免连续题材相同。
- 结构清晰，易于实现，时间复杂度和空间复杂度均为 $O(n)$。