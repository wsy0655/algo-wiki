

## 题目分析

- 有一排 $n$ 个花盆，初始高度均为 $0$；
- 有两种操作：
  - `water l r`：将花盆 $l$ 到 $r$ 的高度均加 1；
  - `rise l r k`：对于花盆 $l$ 到 $r$，若花盆高度 $\ge k$，摘下该花（高度变为 0），输出摘下花的数量；
- 对每个 `rise` 操作输出摘下花的个数。

---

## 解题思路

- 因为 $n,m \leq 1000$，可直接用数组模拟；
- 使用一个数组 `h` 存储每个花盆当前高度；
- 遍历操作：
  - `water`：对 $[l,r]$ 区间高度加 1；
  - `rise`：对 $[l,r]$ 区间判断高度，若 $\ge k$ 则计数并将其置为 0；
- 每个 `rise` 操作输出计数。

---

## 处理流程

-  定义数组 `int h[1005]`，所有元素初始设为 $0$，定义全局数组自动实现；
- 依次读取 $m$ 条操作，执行 `while (m--)` 即可：
     - 若为 `water l r`，对 `h[l...r]` 全部加 1；
         - 即循环遍历 $h_l\sim h_r$ 执行 `h[i] ++`。
     - 若为 `rise l r k`，遍历 `h[l...r]`，统计高度 $\ge k$ 的数量并置为 $0$，输出数量。
         - 即循环遍历 $h_l\sim h_r$，若 `h[i] >= k`，令 `sum++` 同时重置 `h[i] = 0`。

---



## 复杂度分析

- 每个操作最多更新或遍历 $O(n)$ 个花盆；
- 总复杂度为 $O(m \times n)$，在 $n,m \leq 1000$ 时可接受。

---

## 总结

- 该问题适合直接模拟，代码简单易实现；
- 注意数组下标和输入的转换，题目编号从 $1$ 开始；
- 保证对每个 `rise` 操作输出正确摘花数量。
