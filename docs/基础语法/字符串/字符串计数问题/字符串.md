## 题意分析

给定两个字符串 $s$ 和 $t$，你可以从中删除任意数量的字符，并对剩余字符重新排列，使得最终两个字符串完全相同。  
现在请你求出操作后字符串 $s$ 的最大可能长度（等价于操作后 $t$ 的长度）。

---

## 解题思路

由于可以随意重排，因此不在意每个字符串的形态。

- 更关心两个字符串每个对应的字母分别出现几次。
    - 例如你有 $3$ 个 `a`，我有 $2$个 `a`，必然需要删去一个，否则怎么重排 $3$ 个 都不可能和 $2$ 个相等。
- 因此开两个计数数组大小都为 $26$，分别统计两个串的小写字母次数映射为 $0$ 到 $25$，然后求对应字母的次数较小值的和

### 步骤如下：

1. **初始化两个统计数组**：
      - `cnt1[26]`：记录字符串 $s$ 中每个小写字母出现的次数；
      - `cnt2[26]`：记录字符串 $t$ 中每个小写字母出现的次数；
      - 数组大小设为 26，对应 `'a'`~`'z'`。

2. **遍历字符串 $s$ 和 $t$**，对每个字符 `c` 执行：
      - `cnt1[c - 'a']++`（针对字符串 $s$）；
      - `cnt2[c - 'a']++`（针对字符串 $t$）。

3. **统计能组成的最大公共子串长度**：
      - 枚举所有字母 `a`~`z`；
      - 对每个字母，取 `min(cnt1[i], cnt2[i])` 表示两个字符串中都包含的该字母的数量；
      - 累加这些最小值即为最大可能的公共子串长度。

---

## 字符映射技巧回顾

为了实现从字符到数组下标的映射，使用：

- `c - 'a'`：将小写字母 `'a'~'z'` 映射到整数 `0~25`；
- 因为只涉及小写英文字母，数组大小固定为 26；
- 这种映射方式常用于**字母计数和频率统计类问题**，高效且易于实现。

---

## 代码实现



```cpp
#include <iostream>
using namespace std;
int cnt1[26], cnt2[26];
int main() 
{
    string s, t;
    cin >> s >> t;
    for (int i = 0; i < s.size(); i++) 
        cnt1[s[i] - 'a']++;
    for (int i = 0; i < t.size(); i++) 
        cnt2[t[i] - 'a']++;
    int res = 0;
    for (int i = 0; i < 26; i++) 
    {
        res += min(cnt1[i], cnt2[i]);
    }
    cout << res;
    return 0;
}
```



---


## 复杂度分析

- **时间复杂度**：$O(|s| + |t| + 26)$ ≈ $O(N)$，其中 $N$ 为字符串的总长度；
- **空间复杂度**：$O(1)$，因为只用了两个长度为 26 的固定数组。

---



## 总结

- 本题是常见的**双字符串匹配问题**；
- 重点在于用两个频率数组统计字符次数，并逐位取最小值；
- 实现简单但十分典型，适合练习**字符串计数与映射技巧**。
