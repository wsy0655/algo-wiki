## 题意分析

给定一个字符串 $S$，你可以对其中的所有字符重新排列（即任意打乱顺序）。任务是输出所有这些排列中**字典序最小**的那个字符串。

---

## 解题思路

为了让字符串的排列在字典序中最小，只需要将所有字符**按从小到大排序**即可。排序后的字符拼接起来的字符串，一定是所有排列中字典序最小的。

---

## C++ 实现中的排序说明

### 字符串排序

在 C++ 中，字符串本质上是一个字符序列（类似于字符数组），因此可以直接使用 `sort()` 函数来排序。写法如下：

```cpp
sort(s.begin(), s.end());
```

这里 `s.begin()` 和 `s.end()` 分别表示字符串 `s` 的起始位置和结束位置。是迭代器。

局部下标 $[l,r]$ 排序。

- `sort(s.begin() + l, s.begin() + r + 1);`


该语句会直接修改字符串本身，将其中的字符按升序排列。如果需要从大到小排序，则需要使用第三个参数 `greater<>()`。

例如 `sort(s.begin(), s.end(), greater<>())`，`sort(s.begin() + l, s.begin() + r + 1, greater<>());`。


### 数组排序

在 C++ 中，数组本质上是一个元素序列，因此也可以使用 `sort()` 函数来排序。写法如下：

```cpp
for (int i = 0; i < n; i++) cin >> a[i];
sort(a, a + n);

// 局部下标 $[l,r]$ 排序
sort(a + l, a + r + 1);
```

如果输入的下标从 $1$ 开始则为：

```cpp
for (int i = 1; i <= n; i++) cin >> a[i];
sort(a + 1, a + n + 1);

// 局部下标 $[l,r]$ 排序
sort(a + l, a + r + 1);
```

这里 `a` 表示数组的起始位置，`n` 表示数组的长度。如果从大到小排序，则需要使用第三个参数 `greater<>()`。

例如 `sort(a, a + n, greater<>())`，`sort(a + l, a + r + 1, greater<>());`。


### 字符串排序与数组排序的区别（C++）

| 排序对象 | 写法                          | 参数类型 |
|----------|-------------------------------|----------|
| 字符串   | `sort(s.begin(), s.end());`     | 迭代器   |
| 数组     | `sort(a, a + n);`              | 指针     |


## 具体实现

借助 `sort` 函数，直接对整个字符串从小到大排序即可得到答案。最后输出字符串 $s$ 即可。

## 复杂度总结

- 时间复杂度：$O(n\log n)$，其中 $n$ 为字符串长度；
- 空间复杂度：$O(1)$（就地排序，不开辟额外空间）


## 总结

- 将字符串排序即可得到字典序最小的排列；
- `C++` 中对字符串使用 `sort(s.begin(), s.end())`；
- 与数组的 `sort(a, a + n)` 写法不同，注意参数是迭代器还是指针。



