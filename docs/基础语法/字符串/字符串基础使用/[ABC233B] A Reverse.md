## 题意分析

给定一个字符串 $S$，我们需要将其从第 $L$ 个字符到第 $R$ 个字符这段子串的顺序**颠倒**（即反转），然后输出整个字符串。

需要注意：

- $L, R$ 是从 **1 开始计数** 的；
- 反转仅影响位置 $L$ 到 $R$ 的部分，其它部分保持不变；
- 输出修改后的完整字符串。

---

## 解题思路

本题本质是对字符串的某一段子串进行原地反转操作。由于字符串可看作字符数组，我们可以利用编程语言中的 `reverse` 操作对其子区间进行反转。

### 步骤如下：

- 将字符串 $S$ 转换为可修改的字符数组（如列表）；
- 注意输入的 $L,R$ 是 **从 1 开始计数**，而字符串中下标是从 $0$ 开始，因此：
     - 实际要反转的是 $S[L-1:R-1]$ 这一段；
- 使用原地 `reverse` 操作反转这一段子串；
- 再将修改后的字符数组拼接成字符串输出即可。

---

## 关键函数：`reverse`


- C++：`reverse(s.begin() + l, s.begin() + r + 1)`
  - 其作用是反转下标 $[l,r]$ 之间的子串。该函数没有返回值无需赋值，直接在原字符串的基础上修改。
- 翻转整个字符串：`reverse(s.begin(), s.end())`

---

## 示例讲解

以样例 $1$ 为例：

- 输入：`L = 3`, `R = 7`, `S = "abcdefgh"`
- 下标换算：`S[2:6] = "cdefg"`，反转后为 `"gfedc"`
- 最后结果为：`abgfedch`

---

## 时间复杂度分析

- 子串反转操作耗时 $O(R-L+1)$；
- 总体处理为一次遍历 + 一次反转，时间复杂度为 $O(N)$，其中 $N$ 为字符串长度；
- 空间复杂度为 $O(N)$（构造新字符串或字符数组）。

---

## 总结

- 本题考察字符串区间操作及基础索引转换；
- 合理利用语言内置的反转函数，可快速实现；
- 注意输入下标从 $1$ 开始，需转换为从 $0$ 开始的索引使用。

该题操作简洁明了，适合作为字符串处理入门题。
