## T1

**题意分析**

给定一个两位数 $a$ 和一个目标个位数字 $b$，允许对 $a$ 加上一个非负整数 $x$，使得：

$$
a + x
$$

的个位数字等于 $b$，并且 $x$ 尽可能小。

例如：当 $a=13,b=5$，则 $x=8$。

---

**解题思路**

分类讨论处理：

首先令 $t=a\bmod 10$，其中 $\bmod$ 表示取余。即 $t$ 是 $a$ 的个位数字。


- 当 $t\leq b$ 时，$x=b-t$。
- 当 $t>b$ 时，$x=b+10-t$。


____


## T2

**解题思路**


题目给出的座位顺序为：

$$
99,97,\ldots,3,1,0,2,4,\ldots,96,98
$$

可以发现：

* 所有 **奇数座位** 按从大到小排列
* 然后所有 **偶数座位** 按从小到大排列

因此，整个序列可以看作由两部分组成：

1. 奇数部分：$99,97,\ldots,1$，共 $50$ 个
2. 偶数部分：$0,2,4,\ldots,98$，共 $50$ 个

---

因此可以使用分类讨论的思想完成本题：


**情况一：$a,b$ 均为奇数**

说明此时 $a,b$ 处于左半部分，但注意题目并没有规定 $a,b$ 的相对位置，因此无法确定 $a$ 在 $b$ 的左边还是右边。

观察规律：$99$ 是第 $50$ 个奇数，$1$ 是第 $1$ 个奇数。因此

$a$ 是第 $\lfloor\dfrac{a}{2}\rfloor +1$ 个奇数，$b$ 是第 $\lfloor\dfrac{b}{2}\rfloor +1$ 个奇数。

因此答案为：$|(\lfloor\dfrac{a}{2}\rfloor +1)-(\lfloor\dfrac{b}{2}\rfloor +1)|-1$。


____


**情况二：$a,b$ 均为偶数**

说明此时 $a,b$ 处于右半部分，思路同奇数。

因此答案为：$|(\lfloor\dfrac{a}{2}\rfloor+1)-(\lfloor\dfrac{b}{2}\rfloor +1)|-1$。


____



**情况三：$a,b$ 奇偶性不同**

不难证明答案为：$(\lfloor\dfrac{a}{2}\rfloor+1)+(\lfloor\dfrac{b}{2}\rfloor+1)-2=\lfloor\dfrac{a}{2}\rfloor+\lfloor\dfrac{b}{2}\rfloor$


____


**实现步骤**

使用 `if - else` 语句完成分类讨论：

- 当 `a % 2 == b % 2` 时，按照情况一和情况二处理。求绝对值可以使用 `abs` 函数，求向下取整直接使用 `/` 即可。
- 否则说明奇偶性不同，按照情况三处理即可。

____



## T3


**解题思路**



设第 $i$ 次开门使用的密码为 $x_i$。

根据题意：

* 第一次开门使用的密码为初始密码：

  $$
  x_1 = x_1
  $$

* 每次开门 **之后**，密码都会更新为：

  $$
  x_{i+1} = (x_i^2 + C) \bmod 10000
  $$

题目要求的是 **第 $k$ 次开门时使用的密码 $x_k$**。

---


这是一个典型的递推循环过程：

* 已知 $x_1$
* 通过固定公式反复更新密码
* 每次更新只与上一次的密码有关

因此，可以直接按照定义模拟这个过程。

注意：

* 第一次开门不需要进行任何计算
* 从第二次开门开始，才会进行密码更新

---



从 $i=1$ 开始：

* 当 $i=1$ 时，当前密码为 $x_1$
* 对于 $i \ge 2$，重复执行：

  $$
  x_i = (x_{i-1}^2 + C) \bmod 10000
  $$

连续更新 $k-1$ 次后，即可得到第 $k$ 次开门的密码。

---



1. 读入 $x_1,C,k$
2. 设当前密码 $x=x_1$
3. 重复执行 $k-1$ 次：
      * 更新 $x=(x^2+C)\bmod 10000$
4. 输出 $x$

使用 `for` 循环即可实现。


___


## T4



队伍中共有 $n$ 个人，按原顺序依次为：

$$
t_1,t_2,\ldots,t_n
$$

其中 $t_i$ 表示第 $i$ 个人的航班还有多少分钟起飞。

机场的调整规则是：

* 所有满足 $t_i \le 15$ 的人，需要被移动到队伍最前面
* **这些人之间的相对顺序不变**
* 其余 $t_i > 15$ 的人排在后面，**相对顺序同样不变**

这本质上是一个**稳定分类问题**。

---

核心思路

可以将队伍分成两类人：

1. **优先人群**：$t_i \le 15$
2. **普通人群**：$t_i > 15$

只要：

* 按原顺序扫描队伍
* 分别收集这两类人
* 最后将“优先人群”接在“普通人群”前面即可

这样能够保证相对顺序不被破坏。

---

构造方式

设两个序列：

* $A$：存放所有满足 $t_i \le 15$ 的人，按出现顺序加入
* $B$：存放所有满足 $t_i > 15$ 的人，按出现顺序加入

最终队伍为：

$$
A \text{ 后接 } B
$$

---

算法步骤

- 定义数组 `int a[10005], b[10005]` 存储优先人群和普通人群。
- 创建两个变量 `int tot1 = 0, tot2 = 0`，分别记录优先人群和普通人群的个数。
- 读入 $n$ 个人的排队时间 $t$：
    - 当 $t\leq 15$，更新 `a[++tot1] = t`。
    - 否则，更新 `b[++tot2] = t`。
- 遍历 $a$ 数组，输出 $a[1]\sim a[tot1]$。
- 遍历 $b$ 数组，输出 $b[1]\sim b[tot2]$。


____


## T5


整体结构分析

题目中的右箭头由两部分组成：

1. **右侧等腰三角形**
2. **左侧横杠矩形**

并且整个图形满足：

* **上下对称**
* 等腰三角形的上半部分第 $i$ 行占据 $i$ 个格子
* 总行数为 $n$，总列数为 $m$
* 横杠高度为 $k$

由于 $n$ 为奇数，可以确定箭头的**中轴行**为：

$$
mid=\frac{n-1}{2}
$$

---

右侧三角形的形态

以中轴行为分界：

* 在第 $mid$ 行，三角形达到最大宽度
* 向上、向下每远离中轴一行，占据的格子数减少 $1$

设当前行为 $i$，则该行在三角形部分占据的格子数为：

$$
len = \frac{n+1}{2} - |i - mid|
$$

这些格子始终**右对齐**，即从第 $m-len$ 列到第 $m-1$ 列填充 `#`。

---

横杠矩形的范围

横杠位于图形的中间，共占据 $k$ 行：

* 起始行：

  $$
  L = mid - \frac{k-1}{2}
  $$

* 结束行：

  $$
  R = mid + \frac{k-1}{2}
  $$

在这些行中，横杠会向左延伸，填满从第 $0$ 列到第 $m-1$ 列中**不属于三角形的部分**。

也可以理解为：
在横杠所在的行，**三角形左侧的所有位置全部填充 `#`**。

---

每一行的填充规则

对每一行 $i$：

1. 先计算该行三角形应占据的格子数 $len$
2. 默认该行只有右侧三角形部分填充 `#`
3. 若当前行满足 $L \le i \le R$，则：

   * 将该行中三角形左侧的所有格子也填充为 `#`
4. 其余位置填充 `.`

---

算法步骤

1. 读入 $n,m,k$
2. 计算中轴行 $mid=\dfrac{n-1}{2}$
3. 计算横杠的起止行 $L,R$
4. 对每一行 $i=0$ 到 $n-1$：

   * 计算 $len=\dfrac{n+1}{2}-|i-mid|$
   * 初始化整行为 `.`
   * 将区间 $[m-len,m-1]$ 置为 `#`
   * 若 $L \le i \le R$，将区间 $[0,m-len-1]$ 置为 `#`
5. 按行输出结果



___


## T6


问题拆解

本题分为**两轮比赛**，需要按顺序处理：

1. **团体赛**：
   比较每一列同学的知识水平总和，选出总和最大的那一列

   * 若有多列总和相同，选择**最右边**的一列

2. **个人赛**：
   在第一轮胜出的那一列中：

   * 找出最大的知识水平
   * 统计该最大值出现的次数

最终输出这两个结果。

---

第一轮：确定胜出列

设第 $j$ 列同学的知识水平总和为：

$$
S_j = \sum_{i=1}^{n} a_{i,j}
$$

遍历所有列，维护：

* 当前最大总和 $maxSum$
* 对应的列编号 $col$

更新规则为：

* 若 $S_j > maxSum$，更新
* 若 $S_j = maxSum$，选择编号更大的列，即更靠右的一列

这样即可满足题目中的判定规则。

---

第二轮：确定最终赢家

在第一轮胜出的列 $col$ 中，考虑该列的所有元素：

$$
a_{1,col},a_{2,col},\ldots,a_{n,col}
$$

需要做两件事：

1. 求出这一列中的最大值：

   $$
   maxVal = \max_{1 \le i \le n} a_{i,col}
   $$

2. 统计该最大值出现的次数，记为 $cnt$

---

算法步骤

1. 读入 $n,m$ 和矩阵 $a$
2. 初始化 $maxSum=-1$，$col=0$
3. 对每一列 $j=1$ 到 $m$：
      * 计算该列的总和 $S_j$
      * 按规则更新 $maxSum$ 和 $col$
4. 在第 $col$ 列中遍历所有行：
      * 计算最大值 $maxVal$
      * 统计其出现次数 $cnt$
5. 输出 $maxVal$ 和 $cnt$
