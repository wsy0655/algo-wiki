## T1



给定：

* ICPC：从 $a$ 年开始（含 $a$ 年），每年举办 $b$ 场；
* CCPC：从 $c$ 年开始（含 $c$ 年），每年举办 $d$ 场；
* 询问猪历 $x$ 年，这一年两个比赛系列共举办多少场。

只需要判断该年是否已经开始举办对应赛事：

* 若 $x \ge a$，ICPC 在该年举办 $b$ 场，否则为 $0$；
* 若 $x \ge c$，CCPC 在该年举办 $d$ 场，否则为 $0$。



---

**实现流程**

1. 输入 $a,b,c,d,x$
2. 将答案变量初始化为 $0$
3. 如果 $x \ge a$，令答案加上 $b$
4. 如果 $x \ge c$，令答案加上 $d$
5. 输出最终答案

---



## T2

**思路解析**

四支队伍为 $A,B,C,D$，在两场比赛中的排名分别为：

* 第一场：$A_1,B_1,C_1,D_1$
* 第二场：$A_2,B_2,C_2,D_2$

我们要统计有多少对 $(x,y)$ 满足：

* 在第一场中：$x$ 的排名小于 $y$ 的排名
* 在第二场中：$x$ 的排名大于 $y$ 的排名


若成立，则这对队伍为一对“旗鼓相当的对手”。

四支队伍为 $A,B,C,D$，取所有**不重复**的无序队伍对 $(x,y)$，一共正好 $6$ 对，具体如下：

$$
(A,B),\quad (A,C),\quad (A,D),\quad (B,C),\quad (B,D),\quad (C,D)
$$

这六对逐一检查即可。



---

**实现流程**

1. 读入 $A_1,B_1,C_1,D_1$ 和 $A_2,B_2,C_2,D_2$
2. 将队伍编号设为数组下标，存入两场比赛的排名
3. 定义答案变量 `ans = 0`
4. 利用 $6$ 个 `if` 语句检查所有无序对 $(x,y)$。若成立则 `ans++`。
5. 输出 `ans`



```cpp
int count = 0;
// 检查 A 和 B
if ((A1 < B1 && A2 > B2) || (A1 > B1 && A2 < B2)) count++;
// 检查 A 和 C
if ((A1 < C1 && A2 > C2) || (A1 > C1 && A2 < C2)) count++;
// 检查 A 和 D
// ... (类似地检查其他队伍对)
```

---


## T3

**思路解析**

题目给出了一个队伍对所有题目的 **有效提交记录**，每条记录包含：

* 提交时间 $a_i$
* 提交结果 $b_i$（$0$ 表示未通过，$1$ 表示通过）

由于所有提交记录都是“有效提交”，因此满足：

* 同一道题目的最后一次有效提交一定是通过
* 之前的有效提交一定是未通过

同时，题目特别说明：
**虽然罚时按题目划分定义，但最终计算总罚时时不需要区分题号。**

因此，每条提交记录都可以看作“属于某题的一次有效提交”，而每次 $b_i = 1$，代表某一道题通过，其罚时贡献为：

$$
a_i + 20 \times (\text{该题此前的未通过数})
$$

我们需要求所有题的总罚时。

---

**实现流程**

1. 定义答案变量 `long longans = 0`
2. 读入 $n$ 条比赛记录
3. 当 $b=1$ 时，将 `ans += a`。
4. 否则，将 `ans += 20`。
5. 输出 `ans`。

---



## T4


**思路解析**

题目给出了每道题目的所有 **有效提交记录**，每条记录为：

* `0`：未通过
* `1`：通过

对于第 $i$ 道题：

* 有效提交总数为 $a_i$
* 其中通过次数为 $y$
* 未通过次数为 $x - y$

根据定义，该题的 dirt 率为：

$$
\mathrm{dirt}(i) = \frac{a_i - y}{a_i}
$$

因此，我们只需统计每行中 $1$ 的个数即可。

---

**实现流程**

- 输入 $n$：题目数量
- 对每道题重复以下步骤：
     - 读入 $a_i$
     - 读入接下来的 $a_i$ 个数字
     - 统计其中 $1$ 的个数，记为 $y$
     - 计算：

$$
\text{ans} = \frac{a_i - y}{a_i}
$$

- 输出结果（自行控制小数位数，推荐输出至少 3 位以上小数）
- 所有结果各占一行




## T5


**题目分析**

- 给定一支队伍的提交记录，共有 $n$ 条，每条包含题目编号 $pid$ 和状态 $state$（$0$ 表示未通过，$1$ 表示通过）；
- 题目数量为 $p$；
- 我们需要统计这支队伍最终通过了多少道不同的题目；
- 只有在第一次成功通过某题时，提交才是有效，之后即使该题再次通过，也不算新的通过。

---

**解题思路**

- 使用一个布尔数组（或整型数组）`passed` 长度为 $1005$，用于标记每道题是否已经被通过；
- 初始化所有题目状态为未通过（全局数组自动初始化均为 `0`）；
- 逐条遍历提交记录：
    - 如果当前提交状态为通过 ($state = 1$) ，则将对应的题目编号标记为通过(`1`)；
    - 无需判断每道题是否是第一次成功通过，反正过了就算 $1$ 次，标记为 $1$ 即可。
- 最终统计 `passed` 中为 `1` 的题目个数即为答案。

---

**实现步骤**

- 读入 $n, p$；
- 定义全局变量 `bool passed[1005]` 数组，给每道题是否通过打标记；
- 对 $n$ 条提交依次读取 `pid, state`，用两个变量一边输入一边做即可：
     - 若 `state == 1`，则将 `passed[pid] = 1`；
- 统计并输出 `passed` 数组中 `passed[1]` $\sim$ `passed[p]` 中 $1$ 的数量。