## T1 


考察顺序结构。

$x$ 年 $y$ 月至 $2016$ 年 $8$ 月，共过去了 $x−2016$ 年 $y−8+1$ 个月。

因此，答案即为 $12×(x−2016)+y−7$。


<details><summary>核心代码</summary>

```c++
cout << 12 * (x - 2016) + y - 7;
```

</details>


___


## T2


考察分支结构。

本题考查三关键字比较。

给出两只战队的 $w,c,t$ 三个指标，

首先，判断 $w_a$ 与 $w_b$ 是否相等。

- 如果不相等，根据 $w_a$ 与 $w_b$ 的大小关系输出答案。并结束程序。
- 如果相等，则：
    - 判断 $c_a$ 与 $c_b$ 是否相等。
        - 如果不相等，根据 $c_a$ 与 $c_b$ 的大小关系输出答案。并结束程序。
        - 如果相等，则根据 $t_a$ 与 $t_b$ 的大小关系输出答案。并结束程序。 


<details><summary>核心代码</summary>

```c++
if (wa != wb)
{
    if (wa > wb)
        cout << "A";
    else
        cout << "B";
}
else // 表示 wa == wb，需要进一步比较
{
    if (ca != cb)
    {
        if (ca > cb)
            cout << "A";
        else
            cout << "B";
    }
    else
    {
        if (ta > tb)
            cout << "A";
        else
            cout << "B";
    }
}
```

</details>


____



## T3

本题考察简单循环。

首先求出 $sum=1+2+3+...+n$。

则任意的 $i$ 等奖的中奖概率就是 $\frac{i}{sum}$。


现在题目需要求出获奖概率不低于 $m\%$ 的情况下，最好的奖项是几等奖。也就是找到一个整数 $i$ 使得 $\frac{i}{sum}\ge m\%$。且 $i$ 最小。


可以用 `for` 循环罗列所有可能的 $i$ ，并判断 $\frac{i}{sum}\ge m\%$。

注意数据范围。


<details><summary>核心代码</summary>

```c++
int n;
double m;
cin >> n >> m;
long long sum = 0; // 存储 1+2+3+...+n
for (int i = 1; i <= n; i++)
{
    sum += i;
}
for (int i = 1; i <= n; i++)
{
    if (1.0 * i / sum >= m / 100) 
    {
        cout << i;
        return 0;
    }
}
cout << -1; // 找不到输出 -1
return 0;
```

</details>


___


## T4


本题考察简单循环。


枚举每一天这粒种子的成长值，假设当前为第 $t$ 天，首先这粒种子的成长值会增长 $\lfloor \frac{t}{w}\rfloor$，其次若 $t\geq x$，则成长值还会增加 $y$。若此时的成长值不低于 $k$，则代表种子在这一天破土而出。


<details><summary>核心代码</summary>

```c++
int x, y, w, k;
cin >> x >> y >> w >> k;
int sum = 0;
for (int t = 1; ; t++) // 不写循环条件就是无限循环
{
    sum = sum + t / w;
    if (t >= x)
        sum += y;
    if (sum >= k)
    {
        cout << t;
        return 0;
    }
}
```

</details>


___


## T5


本题考察计数数组。


注意到数据范围，$1\leq t\leq 4$。因此，$10^t$ 在 $10\sim 10000$ 的范围内，特征值的后 $t$ 位范围为 $[0,9999]$。

可以使用计数数组 `int cnt[10000]` 来统计 $0～9999$ 范围内出现的次数。

最后遍历计数数组，统计其中不为 $0$ 的个数，即为答案。（`cnt[i] != 0` 说明 $i$ 出现了，因此答案加 $1$）


<details><summary>核心代码</summary>

```c++
int cnt[10000]; // 全局变量初始化均为 0
int main()
{
    int P = pow(10, t); // 求出 10^t
    for (int i = 1; i <= n; i++)
    {
        int x;
        cin >> x;
        x %= P; // 获取后 t 位
        cnt[x]++;
    }
    int sum = 0;
    // 注意这里循环是遍历 0 ~ P - 1 而不是 1 ~ n 想一想为什么。
    for (int i = 0; i < P; i++)
    {
        if (cnt[i] != 0)
        {
            sum++;
        }
    }
    cout << sum;
}
```

</details>