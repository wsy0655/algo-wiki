## çŸ©é˜µå¿«é€Ÿå¹‚

é¢˜æ„ï¼šç»™å®šä¸€ä¸ª $n\times n$ çš„çŸ©é˜µ $A$ï¼Œæ±‚ $A^k$ã€‚çŸ©é˜µæ¯ä¸ªå…ƒç´ å¯¹ $10^9+7$ å–æ¨¡ã€‚

- $n\leq 10^2,k\leq 10^{12}$ã€‚

ç”±äºçŸ©é˜µä¹˜æ³•æ»¡è¶³ç»“åˆå¾‹ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨å¿«é€Ÿå¹‚ä¼˜åŒ–ã€‚

ä¾‹å¦‚ï¼š$A^{13}=A^{8}\cdot A^{4}\cdot A^{1}$ã€‚ä¹Ÿå°±æ˜¯åˆ©ç”¨å€å¢ç»´æŠ¤å‡ºçŸ©é˜µ $A$ çš„ $2$ çš„æ¬¡å¹‚çš„ç»“æœå³å¯åŠ é€Ÿã€‚

æˆ‘ä»¬ç±»æ¯”ç€ä¹‹å‰æ•´æ•°å¿«é€Ÿå¹‚çš„å†™æ³•å»å†™å³å¯ã€‚è¿™æ˜¯ä¹‹å‰çš„å†™æ³•ï¼š

```cpp
ll ksm(ll a, ll b)
{
    ll res = 1;
    while (b)
    {
        if (b & 1) 
            res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}
```

é‚£ä¹ˆåœ¨åšçŸ©é˜µå¿«é€Ÿå¹‚æ—¶ï¼Œé¦–å…ˆåˆå§‹åŒ–çŸ©é˜µ `res` ä¸ºå•ä½çŸ©é˜µ $I$ã€‚

> å•ä½çŸ©é˜µä¿è¯çŸ©é˜µä¹˜æ³•ç»“æœä¸å˜ã€‚ç¡®ä¿ç¬¬ä¸€æ¬¡ä¹˜æ³•ç»“æœä¸åŸçŸ©é˜µä¸€è‡´ã€‚

æ¥ä¸‹æ¥åˆ©ç”¨é‡è½½è¿ç®—ç¬¦æŠ€å·§å®ç°çŸ©é˜µå¿«é€Ÿå¹‚å³å¯ã€‚

æ—¶é—´å¤æ‚åº¦ï¼š$O(n^3\log{k})$ã€‚

```cpp
struct matrix
{
    int mat[N][N];
    matrix()  // æ„é€ å‡½æ•°
    {
        memset(mat, 0, sizeof(mat));
    }
};
matrix operator * (const matrix &a, const matrix &b)  // çŸ©é˜µä¹˜æ³•
{
    matrix c;
    for (int k = 1; k <= n; k++)
    {
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                c.mat[i][j] = (c.mat[i][j] + 1ll * a.mat[i][k] * b.mat[k][j]) % mod;
            }
        }
    }
    return c;
}
matrix operator ^ (matrix &a, ll b)
{
    matrix res;
    for (int i = 1; i <= n; i++) res.mat[i][i] = 1; // å•ä½çŸ©é˜µ
    while (b)
    {
        if (b & 1) res = res * a; // æ³¨æ„ä¸è¦å†™æˆ a * res
        a = a * a;
        b >>= 1;
    }
    return res;
}
```

____


## çŸ©é˜µä¹˜æ³•åŠ é€Ÿé€’æ¨



æ–æ³¢é‚£å¥‘æ•°åˆ—å®šä¹‰ï¼š

$$
\begin{cases}
F_1 = 1, \; F_2 = 1 \\
F_n = F_{n-1} + F_{n-2}, \quad n \ge 3
\end{cases}
$$

ç›®æ ‡ï¼šå¿«é€Ÿæ±‚ç¬¬ $n$ é¡¹ï¼Œå½“ $n$ å¾ˆå¤§ï¼ˆæ¯”å¦‚ $10^{18}$ï¼‰æ—¶ï¼Œç›´æ¥é€’æ¨å¤ªæ…¢ï¼Œéœ€è¦çŸ©é˜µåŠ é€Ÿã€‚

---

### **æ–¹æ³•ä¸€ï¼šåˆ—å‘é‡æ³•**

#### 1. æ„é€ åˆ—å‘é‡

æŠŠä¸¤é¡¹æ‰“åŒ…æˆåˆ—å‘é‡ï¼š

$$
\mathbf{v}_i = 
\begin{bmatrix} F_i \\ F_{i-1} \end{bmatrix}
$$

#### 2. æ„é€ é€’æ¨çŸ©é˜µ

æˆ‘ä»¬å¸Œæœ›ï¼š

$$
A\cdot \mathbf{v}_i=\mathbf{v}_{i+1}
$$

å› æ­¤å¯çŸ¥ $A$ æ˜¯ä¸€ä¸ª $2\times 2$ çš„çŸ©é˜µï¼šå³å°±æ˜¯

$$
\begin{bmatrix} a & b \\ c & d \end{bmatrix}\cdot \begin{bmatrix} F_i \\ F_{i-1} \end{bmatrix}=\begin{bmatrix} F_{i+1} \\ F_{i} \end{bmatrix}
$$

æŒ‰ç…§ **åˆ—å‘é‡çº¿æ€§ç»„åˆè§†è§’** ï¼Œå¯ä»¥å¾—åˆ°ï¼š

$$
F_i \begin{bmatrix} a \\ c \end{bmatrix}+F_{i-1}\begin{bmatrix} c \\ d \end{bmatrix}=\begin{bmatrix} F_{i+1} \\ F_{i} \end{bmatrix}
$$

å³å¾—åˆ°æ–¹ç¨‹ç»„ï¼š

$$\begin{cases}
a\cdot F_i+c\cdot F_{i-1}=F_{i+1}\\
c\cdot F_i+d\cdot F_{i-1}=F_{i}
\end{cases}$$

æ˜“å¾—çŸ©é˜µ $A$ æ˜¯ï¼š

$$
A = \begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}
$$



#### 3. å¿«é€Ÿæ±‚ç¬¬ $n$ é¡¹

$$
\mathbf{v}_n = A^{n-2} \mathbf{v}_2, \quad 
\mathbf{v}_2 = \begin{bmatrix} F_2 \\ F_1 \end{bmatrix} = \begin{bmatrix} 1 \\ 1 \end{bmatrix}.
$$

* åˆ©ç”¨ **çŸ©é˜µå¿«é€Ÿå¹‚**ï¼ˆ$O(\log n)$ï¼‰å³å¯å¾—åˆ° $F_n$ã€‚
* æ³¨æ„å½“ $n>2$ åœ¨ä½¿ç”¨çŸ©é˜µå¿«é€Ÿå¹‚ã€‚




<details>

<summary>å‚è€ƒä»£ç </summary>

```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;
constexpr int mod = 1e9 + 7;
ll n;
struct matrix
{
    int mat[3][3];
    matrix()  // æ„é€ å‡½æ•°
    {
        memset(mat, 0, sizeof(mat));
    }
};
matrix operator * (const matrix &a, const matrix &b)  // çŸ©é˜µä¹˜æ³•
{
    matrix c;
    for (int k = 1; k <= 2; k++)
    {
        for (int i = 1; i <= 2; i++)
        {
            for (int j = 1; j <= 2; j++)
            {
                c.mat[i][j] = (c.mat[i][j] + 1ll * a.mat[i][k] * b.mat[k][j]) % mod;
            }
        }
    }
    return c;
}
matrix operator ^ (matrix &a, ll b)
{
    matrix res;
    for (int i = 1; i <= 2; i++) res.mat[i][i] = 1; // å•ä½çŸ©é˜µ
    while (b)
    {
        if (b & 1) res = res * a; // æ³¨æ„ä¸è¦å†™æˆ a * res
        a = a * a;
        b >>= 1;
    }
    return res;
}
int main()
{
    ios::sync_with_stdio(false), cin.tie(0);
    cin >> n;
    if (n <= 2)
    {
        cout << 1;
        return 0;
    }
    matrix F;
    F.mat[1][1] = F.mat[2][1] = 1; // åˆ—å‘é‡
    matrix a;
    a.mat[1][1] = a.mat[1][2] = a.mat[2][1] = 1; // è½¬ç§»çŸ©é˜µ
    a = a ^ (n - 2);
    a = a * F;
    cout << a.mat[1][1];
    return 0;
}
```


</details>



---

### **æ–¹æ³•äºŒï¼šè¡Œå‘é‡æ³•**

#### 1. æ„é€ è¡Œå‘é‡

æŠŠä¸¤é¡¹æ‰“åŒ…æˆè¡Œå‘é‡ï¼š

$$
\mathbf{w}_i = \begin{bmatrix} F_{i} & F_{i-1} \end{bmatrix}
$$

#### 2. æ„é€ é€’æ¨çŸ©é˜µ

æˆ‘ä»¬å¸Œæœ›ï¼š

$$
\mathbf{w}_i B=\mathbf{w}_{i+1}
$$

é¦–å…ˆä¾ç„¶å¯ä»¥ç¡®å®š $B$ æ˜¯ä¸€ä¸ª $2\times 2$ çš„çŸ©é˜µã€‚å³å°±æ˜¯

$$
 \begin{bmatrix} F_i & F_{i-1} \end{bmatrix} \cdot \begin{bmatrix} a & b \\ c & d \end{bmatrix}=\begin{bmatrix} F_{i+1} & F_{i} \end{bmatrix}
$$

æŒ‰ç…§ **è¡Œå‘é‡çº¿æ€§ç»„åˆè§†è§’** ï¼Œå¯ä»¥å¾—åˆ°ï¼š


$$\begin{bmatrix}
a\cdot F_i+c\cdot F_{i-1} & b\cdot F_i+d\cdot F_{i-1}
\end{bmatrix}=\begin{bmatrix} F_{i+1} & F_{i} \end{bmatrix}
$$



å› æ­¤çŸ©é˜µ $B$ æ˜¯ï¼š

$$
B = \begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}.
$$



#### 3. å¿«é€Ÿæ±‚ç¬¬ $n$ é¡¹

$$
\mathbf{w}_n = \mathbf{w}_2 B^{n-2}, \quad 
\mathbf{w}_2 = \begin{bmatrix} F_2 & F_1 \end{bmatrix} = \begin{bmatrix} 1 & 1 \end{bmatrix}.
$$

* åŒæ ·ä½¿ç”¨ **çŸ©é˜µå¿«é€Ÿå¹‚**ï¼Œ$O(\log n)$ å¾—åˆ° $F_n$ã€‚



<details>

<summary>å‚è€ƒä»£ç </summary>

```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;
constexpr int mod = 1e9 + 7;
ll n;
struct matrix
{
    int mat[3][3];
    matrix()  // æ„é€ å‡½æ•°
    {
        memset(mat, 0, sizeof(mat));
    }
};
matrix operator * (const matrix &a, const matrix &b)  // çŸ©é˜µä¹˜æ³•
{
    matrix c;
    for (int k = 1; k <= 2; k++)
    {
        for (int i = 1; i <= 2; i++)
        {
            for (int j = 1; j <= 2; j++)
            {
                c.mat[i][j] = (c.mat[i][j] + 1ll * a.mat[i][k] * b.mat[k][j]) % mod;
            }
        }
    }
    return c;
}
matrix operator ^ (matrix &a, ll b)
{
    matrix res;
    for (int i = 1; i <= 2; i++) res.mat[i][i] = 1; // å•ä½çŸ©é˜µ
    while (b)
    {
        if (b & 1) res = res * a; // æ³¨æ„ä¸è¦å†™æˆ a * res
        a = a * a;
        b >>= 1;
    }
    return res;
}
int main()
{
    ios::sync_with_stdio(false), cin.tie(0);
    cin >> n;
    if (n <= 2)
    {
        cout << 1;
        return 0;
    }
    matrix F;
    F.mat[1][1] = F.mat[1][2] = 1; // è¡Œå‘é‡
    matrix a;
    a.mat[1][1] = a.mat[1][2] = a.mat[2][1] = 1; // è½¬ç§»çŸ©é˜µ
    a = a ^ (n - 2);
    a = F * a;
    cout << a.mat[1][1];
    return 0;
}
```



</details>


---

### **æ€»ç»“å¯¹æ¯”**

* æ ¸å¿ƒæ€æƒ³ï¼š**æŠŠé€’æ¨å…³ç³»è½¬åŒ–ä¸ºçŸ©é˜µä¹˜æ³•ï¼ŒæŠŠè¿ç»­é¡¹æ‰“åŒ…ï¼Œé‡å¤çŸ©é˜µä¹˜æ³•å³å¯å¿«é€Ÿå¾—åˆ°ä»»æ„é¡¹**ã€‚
* åˆ—å‘é‡å’Œè¡Œå‘é‡æ–¹æ³•æœ¬è´¨ç›¸åŒï¼Œåªæ˜¯ä¹˜æ³•æ–¹å‘å’ŒçŸ©é˜µå½¢å¼ä¸åŒã€‚

---





## çº¿æ®µæ ‘ç»´æŠ¤çŸ©é˜µä¹˜æ³•



### ä¾‹é¢˜ä¸€ï¼š[THUSC 2017] å¤§é­”æ³•å¸ˆ

é¢˜ç›®ä¸­åŒ…å«å…­ç§ä¿®æ”¹æ“ä½œã€‚æ ¸å¿ƒè§‚å¯Ÿæ˜¯ï¼š

è¿™äº›æ“ä½œéƒ½å¯ä»¥è½¬åŒ–ä¸ºå¯¹åˆ—å‘é‡

$$
\begin{bmatrix} A \\ B \\ C \\ 1 \end{bmatrix}
$$

çš„**çº¿æ€§å˜æ¢**ï¼Œå³ç­‰ä»·äºå·¦ä¹˜æŸä¸ª $4\times 4$ çŸ©é˜µã€‚

---

**å„æ“ä½œçš„çŸ©é˜µè¡¨ç¤º**

**æ“ä½œä¸€ï¼š$A_i \gets A_i + B_i$**

$$
\begin{bmatrix} 
1 & 1 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix} A \\ B \\ C \\ 1 \end{bmatrix}=
\begin{bmatrix} A+B \\ B \\ C \\ 1 \end{bmatrix}
$$

---

**æ“ä½œäºŒã€ä¸‰**ï¼šä¸æ“ä½œä¸€ç±»ä¼¼ï¼Œç•¥ã€‚

---

**æ“ä½œå››ï¼š$A_i \gets A_i + v$**

$$
\begin{bmatrix} 
1 & 0 & 0 & v \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix} A \\ B \\ C \\ 1 \end{bmatrix}=
\begin{bmatrix} A+v \\ B \\ C \\ 1 \end{bmatrix}
$$

---

**æ“ä½œäº”ï¼š$B_i \gets B_i \cdot v$**

$$
\begin{bmatrix} 
1 & 0 & 0 & 0 \\
0 & v & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix} A \\ B \\ C \\ 1 \end{bmatrix}=
\begin{bmatrix} A \\ B\cdot v \\ C \\ 1 \end{bmatrix}
$$

---

**æ“ä½œå…­ï¼š$C_i \gets v$**

$$
\begin{bmatrix} 
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 0 & v \\
0 & 0 & 0 & 1 
\end{bmatrix}
\begin{bmatrix} A \\ B \\ C \\ 1 \end{bmatrix}=
\begin{bmatrix} A \\ B \\ v \\ 1 \end{bmatrix}
$$

---

**è§£é¢˜æ–¹æ³•**

ç”±æ­¤å¯çŸ¥ï¼Œæ‰€æœ‰æ“ä½œéƒ½å¯ä»¥æŠ½è±¡ä¸º**çŸ©é˜µä¹˜æ³•**ã€‚å› æ­¤å¯ä»¥åœ¨çº¿æ®µæ ‘ä¸­ç»´æŠ¤æ¯ä¸ªåŒºé—´çš„çŸ©é˜µæ ‡è®°ï¼Œé€šè¿‡**åŒºé—´çŸ©é˜µä¹˜æ³•**å®ç°æ‰¹é‡ä¿®æ”¹ã€‚

æ³¨æ„è¦ç‚¹ï¼š

1. **çŸ©é˜µä¹˜æ³•å¸¸æ•°è¾ƒå¤§**ï¼š$4^3=64$ æ¬¡è¿ç®—ï¼Œä½†ç”±äºçŸ©é˜µä¸­æœ‰å¤§é‡ $0$ å…ƒç´ ï¼Œå¯ä»¥é€šè¿‡ **ç‰¹åˆ¤/å¾ªç¯å±•å¼€** é™ä½å¸¸æ•°ã€‚
2. **çŸ©é˜µä¸æ»¡è¶³äº¤æ¢å¾‹**ï¼šåœ¨çº¿æ®µæ ‘æ ‡è®°ä¸‹ä¼ æ—¶ï¼Œå¿…é¡»ä¸¥æ ¼åŒºåˆ†â€œè°åœ¨å·¦ã€è°åœ¨å³â€ï¼Œå³ä¿è¯æ“ä½œé¡ºåºæ­£ç¡®ã€‚

---

ğŸ‘‰ è¿™æ ·ï¼Œé—®é¢˜å°±è½¬åŒ–ä¸ºä¸€ä¸ª **çº¿æ®µæ ‘ + çŸ©é˜µä¹˜æ³•** çš„æ¨¡æ¿é¢˜ã€‚





____





### ä¾‹é¢˜äºŒï¼š[NOIP2022] æ¯”èµ›

é¢˜ç›®è¦æ±‚ï¼šç»™å®š $q$ æ¬¡è¯¢é—®ï¼Œè®¡ç®—ï¼š

$$
\sum_{i=l}^r \sum_{j=i}^r \max(a_i,\cdots,a_j)\cdot \max(b_i,\cdots,b_j)
$$

---

**æ€è·¯åˆ†æ**

é¦–å…ˆï¼Œå°†æ‰€æœ‰è¯¢é—®ç¦»çº¿ï¼Œå¹¶æŒ‰å³ç«¯ç‚¹ $r$ æ’åºã€‚

è€ƒè™‘å›ºå®šå³ç«¯ç‚¹ $r$ æ—¶çš„æƒ…å†µï¼š

å®šä¹‰

$$
x_i = \max(a_i,\cdots,a_r), \quad y_i = \max(b_i,\cdots,b_r)
$$

é‚£ä¹ˆæŸ¥è¯¢ç»“æœå¯è½¬åŒ–ä¸ºï¼š

$$
\sum_{i=l}^r x_i \cdot y_i
$$

---

**æš´åŠ›è§£æ³•ï¼ˆ20åˆ†ï¼‰**

æˆ‘ä»¬å¯ä»¥ç›´æ¥ç»´æŠ¤ $x,y,f$ ä¸‰ä¸ªæ•°ç»„ï¼š

* $x[i],y[i]$ï¼šè¡¨ç¤ºåŒºé—´åç¼€æœ€å¤§å€¼
* $f[i]$ï¼šç»´æŠ¤ $\sum x_i \cdot y_i$ çš„å†å²å’Œ

å¤æ‚åº¦ä¸º $O(n^2+nq)$ï¼Œå¦‚ä¸‹ä»£ç ï¼š

<details>

<summary>å‚è€ƒä»£ç </summary>

```cpp
#include <bits/stdc++.h>
#define int unsigned long long
using namespace std;
constexpr int N = 2.5e5 + 5;
int T, n, a[N], b[N], q;

signed main()
{
    ios::sync_with_stdio(false), cin.tie(0);
    cin >> T >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    for (int i = 1; i <= n; i++)
        cin >> b[i];
    cin >> q;
    vector<vector<pair<int, int>>> que(n + 1);
    for (int i = 1; i <= q; i++)
    {
        int l, r;
        cin >> l >> r;
        que[r].push_back({l, i});
    }
    vector<int> x(n + 1), y(n + 1), f(n + 1), ans(q + 1);
    for (int r = 1; r <= n; r++)
    {
        for (int i = 1; i <= r; i++)
        {
            x[i] = max(x[i], a[r]);
            y[i] = max(y[i], b[r]);
            f[i] += x[i] * y[i];
        }
        for (auto [l, i] : que[r])
        {
            for (int j = l; j <= r; j++)
            {
                ans[i] += f[j];
            }
        }
    }
    for (int i = 1; i <= q; i++) cout << ans[i] << "\n";
    return 0;
}
```




</details>

---

**ä¼˜åŒ–æ€è·¯**

è§‚å¯Ÿå‘ç°ï¼ŒæŸ¥è¯¢æœ¬è´¨ä¸Šæ˜¯ **åŒºé—´æ±‚å’Œ**ï¼ŒåŒæ—¶ $f$ çš„æ›´æ–°æ˜¯ **åœ¨å†å²å’Œä¸Šç´¯åŠ **ã€‚

å¦‚æœä»…é çº¿æ®µæ ‘ç»´æŠ¤åŒºé—´å’Œï¼Œéš¾ç‚¹åœ¨äºï¼šéœ€è¦åŒæ­¥ç»´æŠ¤å†å²å’Œã€$x,y$ çš„å˜åŒ–ã€‚

å¯å‘æ¥è‡ª **å•è°ƒæ ˆ**ï¼š

* $a_r$ åªæœ‰åœ¨æˆä¸ºæŸä¸ªåç¼€æœ€å¤§å€¼æ—¶æ‰ä¼šæ›´æ–° $x_i$ï¼›
* åŒç†ï¼Œ$b_r$ ä¹Ÿåªæœ‰åœ¨æˆä¸ºæŸä¸ªåç¼€æœ€å¤§å€¼æ—¶æ‰ä¼šæ›´æ–° $y_i$ã€‚

å› æ­¤ï¼Œæ›´æ–°è¿‡ç¨‹å¯ä»¥æŠ½è±¡ä¸º **åŒºé—´èµ‹å€¼**ã€‚

è€ƒè™‘åœ¨çº¿æ®µæ ‘ä¸­ç»´æŠ¤ä»¥ä¸‹äº”ç±»ä¿¡æ¯ï¼š

* `ans`ï¼šå†å²å’Œ
* $\sum xy$
* $\sum x$
* $\sum y$
* åŒºé—´é•¿åº¦ `len`

---

**çŸ©é˜µç»´æŠ¤è½¬ç§»**

å¯¹åŒºé—´çš„æ“ä½œï¼Œå¯ä»¥ç”¨çŸ©é˜µå·¦ä¹˜ç»Ÿä¸€ç»´æŠ¤ï¼š

- åŒºé—´èµ‹å€¼ $x=v$

$$
\begin{bmatrix} 
1 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & v & 0\\
0 & 0 & 0 & 0 & v\\
0 & 0 & 0 & 1 & 0\\
0 & 0 & 0 & 0 & 1\\
\end{bmatrix}
\cdot
\begin{bmatrix} 
ans \\ \sum xy \\ \sum x \\ \sum y \\ len
\end{bmatrix}
$$

- åŒºé—´èµ‹å€¼ $y=v$

$$
\begin{bmatrix} 
1 & 0 & 0 & 0 & 0\\
0 & 0 & v & 0 & 0\\
0 & 0 & 1 & 0 & 0\\
0 & 0 & 0 & 0 & v\\
0 & 0 & 0 & 0 & 1\\
\end{bmatrix}
\cdot
\begin{bmatrix} 
ans \\ \sum xy \\ \sum x \\ \sum y \\ len
\end{bmatrix}
$$

- æ›´æ–°å†å²å’Œ

$$
\begin{bmatrix} 
1 & 1 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0\\
0 & 0 & 1 & 0 & 0\\
0 & 0 & 0 & 1 & 0\\
0 & 0 & 0 & 0 & 1\\
\end{bmatrix}
\cdot
\begin{bmatrix} 
ans \\ \sum xy \\ \sum x \\ \sum y \\ len
\end{bmatrix}
$$

è¿™æ ·ï¼Œæ¯æ¬¡æ“ä½œéƒ½å¯ä»¥åœ¨çº¿æ®µæ ‘ä¸­å®Œæˆï¼ŒæŸ¥è¯¢æ—¶ $O(\log n)$ã€‚

è™½ç„¶å¸¸æ•°è¾ƒå¤§ï¼Œä½†å¯é€šè¿‡ **å¾ªç¯å±•å¼€ã€å†…è”ä¼˜åŒ–** ç­‰æ–¹å¼é™ä½å¸¸æ•°ã€‚

---

<details>

<summary>å‚è€ƒä»£ç </summary>

```cpp
for (int r = 1; r <= n; r++) 
{
    while (top1 && seq[r].first > seq[stk1[top1]].first) top1--;
    while (top2 && seq[r].second > seq[stk2[top2]].second) top2--;

    matrix op = get(seq[r].first, 1);
    modify(1, 1, n, stk1[top1] + 1, r, op);

    op = get(seq[r].second, 2);
    modify(1, 1, n, stk2[top2] + 1, r, op);

    op = get(1, 3);
    modify(1, 1, n, 1, r, op);
    
    for (auto [l, i] : que[r]) {
        ans[i] = query(1, 1, n, l, r).mat[0][0];
    }
    stk1[++top1] = r, stk2[++top2] = r;
}
```

</details>

---

