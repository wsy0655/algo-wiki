## 矩阵快速幂

题意：给定一个 $n\times n$ 的矩阵 $A$，求 $A^k$。矩阵每个元素对 $10^9+7$ 取模。

- $n\leq 10^2,k\leq 10^{12}$。

由于矩阵乘法满足结合律，因此可以使用快速幂优化。

例如：$A^{13}=A^{8}\cdot A^{4}\cdot A^{1}$。也就是利用倍增维护出矩阵 $A$ 的 $2$ 的次幂的结果即可加速。

我们类比着之前整数快速幂的写法去写即可。这是之前的写法：

```cpp
ll ksm(ll a, ll b)
{
    ll res = 1;
    while (b)
    {
        if (b & 1) 
            res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}
```

那么在做矩阵快速幂时，首先初始化矩阵 `res` 为单位矩阵 $I$。

> 单位矩阵保证矩阵乘法结果不变。确保第一次乘法结果与原矩阵一致。

接下来利用重载运算符技巧实现矩阵快速幂即可。

时间复杂度：$O(n^3\log{k})$。

```cpp
struct matrix
{
    int mat[N][N];
    matrix()  // 构造函数
    {
        memset(mat, 0, sizeof(mat));
    }
};
matrix operator * (const matrix &a, const matrix &b)  // 矩阵乘法
{
    matrix c;
    for (int k = 1; k <= n; k++)
    {
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                c.mat[i][j] = (c.mat[i][j] + 1ll * a.mat[i][k] * b.mat[k][j]) % mod;
            }
        }
    }
    return c;
}
matrix operator ^ (matrix &a, ll b)
{
    matrix res;
    for (int i = 1; i <= n; i++) res.mat[i][i] = 1; // 单位矩阵
    while (b)
    {
        if (b & 1) res = res * a; // 注意不要写成 a * res
        a = a * a;
        b >>= 1;
    }
    return res;
}
```

____


## 矩阵乘法加速递推



斐波那契数列定义：

$$
\begin{cases}
F_1 = 1, \; F_2 = 1 \\
F_n = F_{n-1} + F_{n-2}, \quad n \ge 3
\end{cases}
$$

目标：快速求第 $n$ 项，当 $n$ 很大（比如 $10^{18}$）时，直接递推太慢，需要矩阵加速。

---

### **方法一：列向量法**

#### 1. 构造列向量

把两项打包成列向量：

$$
\mathbf{v}_i = 
\begin{bmatrix} F_i \\ F_{i-1} \end{bmatrix}
$$

#### 2. 构造递推矩阵

我们希望：

$$
A\cdot \mathbf{v}_i=\mathbf{v}_{i+1}
$$

因此可知 $A$ 是一个 $2\times 2$ 的矩阵：即就是

$$
\begin{bmatrix} a & b \\ c & d \end{bmatrix}\cdot \begin{bmatrix} F_i \\ F_{i-1} \end{bmatrix}=\begin{bmatrix} F_{i+1} \\ F_{i} \end{bmatrix}
$$

按照 **列向量线性组合视角** ，可以得到：

$$
F_i \begin{bmatrix} a \\ c \end{bmatrix}+F_{i-1}\begin{bmatrix} c \\ d \end{bmatrix}=\begin{bmatrix} F_{i+1} \\ F_{i} \end{bmatrix}
$$

即得到方程组：

$$\begin{cases}
a\cdot F_i+c\cdot F_{i-1}=F_{i+1}\\
c\cdot F_i+d\cdot F_{i-1}=F_{i}
\end{cases}$$

易得矩阵 $A$ 是：

$$
A = \begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}
$$



#### 3. 快速求第 $n$ 项

$$
\mathbf{v}_n = A^{n-2} \mathbf{v}_2, \quad 
\mathbf{v}_2 = \begin{bmatrix} F_2 \\ F_1 \end{bmatrix} = \begin{bmatrix} 1 \\ 1 \end{bmatrix}.
$$

* 利用 **矩阵快速幂**（$O(\log n)$）即可得到 $F_n$。
* 注意当 $n>2$ 在使用矩阵快速幂。


#### 代码实现


```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;
constexpr int mod = 1e9 + 7;
ll n;
struct matrix
{
    int mat[3][3];
    matrix()  // 构造函数
    {
        memset(mat, 0, sizeof(mat));
    }
};
matrix operator * (const matrix &a, const matrix &b)  // 矩阵乘法
{
    matrix c;
    for (int k = 1; k <= 2; k++)
    {
        for (int i = 1; i <= 2; i++)
        {
            for (int j = 1; j <= 2; j++)
            {
                c.mat[i][j] = (c.mat[i][j] + 1ll * a.mat[i][k] * b.mat[k][j]) % mod;
            }
        }
    }
    return c;
}
matrix operator ^ (matrix &a, ll b)
{
    matrix res;
    for (int i = 1; i <= 2; i++) res.mat[i][i] = 1; // 单位矩阵
    while (b)
    {
        if (b & 1) res = res * a; // 注意不要写成 a * res
        a = a * a;
        b >>= 1;
    }
    return res;
}
int main()
{
    ios::sync_with_stdio(false), cin.tie(0);
    cin >> n;
    if (n <= 2)
    {
        cout << 1;
        return 0;
    }
    matrix F;
    F.mat[1][1] = F.mat[2][1] = 1; // 列向量
    matrix a;
    a.mat[1][1] = a.mat[1][2] = a.mat[2][1] = 1; // 转移矩阵
    a = a ^ (n - 2);
    a = a * F;
    cout << a.mat[1][1];
    return 0;
}
```

---

### **方法二：行向量法**

#### 1. 构造行向量

把两项打包成行向量：

$$
\mathbf{w}_i = \begin{bmatrix} F_{i} & F_{i-1} \end{bmatrix}
$$

#### 2. 构造递推矩阵

我们希望：

$$
\mathbf{w}_i B=\mathbf{w}_{i+1}
$$

首先依然可以确定 $B$ 是一个 $2\times 2$ 的矩阵。即就是

$$
 \begin{bmatrix} F_i & F_{i-1} \end{bmatrix} \cdot \begin{bmatrix} a & b \\ c & d \end{bmatrix}=\begin{bmatrix} F_{i+1} & F_{i} \end{bmatrix}
$$

按照 **行向量线性组合视角** ，可以得到：


$$\begin{bmatrix}
a\cdot F_i+c\cdot F_{i-1} & b\cdot F_i+d\cdot F_{i-1}
\end{bmatrix}=\begin{bmatrix} F_{i+1} & F_{i} \end{bmatrix}
$$



因此矩阵 $B$ 是：

$$
B = \begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}.
$$



#### 3. 快速求第 $n$ 项

$$
\mathbf{w}_n = \mathbf{w}_2 B^{n-2}, \quad 
\mathbf{w}_2 = \begin{bmatrix} F_2 & F_1 \end{bmatrix} = \begin{bmatrix} 1 & 1 \end{bmatrix}.
$$

* 同样使用 **矩阵快速幂**，$O(\log n)$ 得到 $F_n$。



#### 示例代码


```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;
constexpr int mod = 1e9 + 7;
ll n;
struct matrix
{
    int mat[3][3];
    matrix()  // 构造函数
    {
        memset(mat, 0, sizeof(mat));
    }
};
matrix operator * (const matrix &a, const matrix &b)  // 矩阵乘法
{
    matrix c;
    for (int k = 1; k <= 2; k++)
    {
        for (int i = 1; i <= 2; i++)
        {
            for (int j = 1; j <= 2; j++)
            {
                c.mat[i][j] = (c.mat[i][j] + 1ll * a.mat[i][k] * b.mat[k][j]) % mod;
            }
        }
    }
    return c;
}
matrix operator ^ (matrix &a, ll b)
{
    matrix res;
    for (int i = 1; i <= 2; i++) res.mat[i][i] = 1; // 单位矩阵
    while (b)
    {
        if (b & 1) res = res * a; // 注意不要写成 a * res
        a = a * a;
        b >>= 1;
    }
    return res;
}
int main()
{
    ios::sync_with_stdio(false), cin.tie(0);
    cin >> n;
    if (n <= 2)
    {
        cout << 1;
        return 0;
    }
    matrix F;
    F.mat[1][1] = F.mat[1][2] = 1; // 行向量
    matrix a;
    a.mat[1][1] = a.mat[1][2] = a.mat[2][1] = 1; // 转移矩阵
    a = a ^ (n - 2);
    a = F * a;
    cout << a.mat[1][1];
    return 0;
}
```

---

### **总结对比**

* 核心思想：**把递推关系转化为矩阵乘法，把连续项打包，重复矩阵乘法即可快速得到任意项**。
* 列向量和行向量方法本质相同，只是乘法方向和矩阵形式不同。

---


