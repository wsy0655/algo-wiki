## 📌 一、前缀和

---

**🎯 核心概念**

**什么是前缀和？**  
数列前 $i$ 项的和：

$$
pre_i \;=\; a_1 + a_2 + \cdots + a_i
$$

> **它能做什么？**  
> - 快速获取区间和、区间内质数/奇数/偶数个数等  
> - 可拓展至：前缀积、前缀异或等

---

### 🔍 一维前缀和

**1️⃣ 定义**

- 令  
  $$
   pre_i = \sum_{j=1}^i a_j \quad\Longrightarrow\quad pre_i = a_1 + a_2 + \cdots + a_i
 $$
- 例如：  
  - $pre_1 = a_1$ 
  - $pre_2 = a_1 + a_2$  
  - $\cdots$ 
  - $pre_n = a_1 + a_2 + \cdots + a_n$

- **递推关系**  
  $$
   pre_i = pre_{i-1} + a_i
 $$

```cpp
// C++ 示例：维护一维前缀和
for (int i = 1; i <= n; i++) 
{
    cin >> a[i];
    pre[i] = pre[i - 1] + a[i];
}
```


> 💡 注意数据范围是否需要 `long long`。

---

**性质**

- **区间和查询**  
  求区间 $i \sim j$ 内的数字之和，可以使用  
  $$
  pre_j - pre_{i-1}
  $$  
  **证明：**  


$$
\begin{aligned}
pre_j &= a_1 + a_2 + \cdots + a_{i-1} + a_i + \cdots + a_j,\\
pre_{i-1} &= a_1 + a_2 + \cdots + a_{i-1},\\
\Rightarrow\, pre_j - pre_{i-1} &= a_i + \cdots + a_j
\end{aligned}
$$

---

**常见应用**

- **给定 $l, r$**  
  直接用  
  $$
  pre_r - pre_{l-1}
  $$  
  查询区间和。

- **已知起点 $l$ 和区间长度 $len$**  
  终点为 $r = l + len - 1$。然后用  
  $$
  pre_r - pre_{l-1}
  $$  
  查询区间和。

- **注意**  
  前缀和不仅仅局限于 **和**。它主要是预处理的算法，通过一段前缀减去另一段前缀，得到某一段区间的信息。例如：  
  - 区间内质数个数  
  - 区间内奇数/偶数个数/含有 $3$ 的数字个数等  
  - 区间异或值等

---

### 📚 二维前缀和


**预处理：二维前缀和**

- **定义二维前缀和数组**  
  令 $\displaystyle pre[i][j]$ 表示矩阵 $a$ 中子矩阵 $[1..\,i]\times [1..\,j]$ 的元素之和，即  
  $$
  pre[i][j]
  \;=\;
  \sum_{x=1}^{i} \sum_{y=1}^{j} a_{x,y},
  \quad 1 \le i \le n,\;1 \le j \le m.
  $$

- **递推公式**  
  
$$
pre[i][j]=pre[i-1][j]+pre[i][j-1]-pre[i-1][j-1]
+
a_{i,j}
$$

---

**查询公式 & 时间复杂度**

- **查询公式**  
  对于一次查询 $(x_1,y_1)$ 到 $(x_2,y_2)$ 范围内的子矩阵和，按下式计算：  

$$\begin{aligned}
&\sum_{i=x_1}^{x_2} \sum_{j=y_1}^{y_2} a_{i,j}\\
=&pre[x_2][y_2]-pre[x_1-1][y_2]-pre[x_2][y_1-1]+pre[x_1-1][y_1-1].
\end{aligned}$$
  


- **时间复杂度**  
  - 预处理：构造 $pre[i][j]$ 需要 $O(n \times m)$。  
  - 查询：每次常数次访问 $pre$，$O(1)$，共 $Q$ 次故 $O(Q)$。

---



## ✏️ 二、差分

---

### 🔍 一维差分

**🎯 核心概念**

> **什么是差分？**  
> 差分是一种与前缀和相对的技巧，可视为前缀和的逆运算。通过差分数组，我们可以高效地处理某些“区间修改”类问题。  

- 设原数组为 $a_1, a_2, \ldots, a_n$，则差分数组 $b_1, b_2, \ldots, b_n$ 定义为：
    
$$
\begin{cases}
  b_1 = a_1,\\
  b_i = a_i - a_{i-1}, \quad i = 2,3,\ldots,n.
\end{cases}
$$


- **示例：**  
  - $b_1 = a_1$  
  - $b_2 = a_2 - a_1$ 
  - $b_3 = a_3 - a_2$ 
  - $\ldots$

---

**🔹 性质一：前缀还原原数组**

- **结论：**  
  原数组 $a_i$ 等于差分数组 $b$ 的前缀和：  
  $$
  a_i = \sum_{j=1}^i b_j.
  $$
- **证明：**  


$$
\begin{aligned}
a_n &= b_1 + b_2 + \cdots + b_n \\
    &= a_1 + (a_2 - a_1) + (a_3 - a_2) + \cdots + (a_n - a_{n-1}) \\
    &= a_n.
\end{aligned}
$$



> 例如：  
>
> $$
> \begin{aligned}
>   a_1 &= b_1,\\
>   a_2 &= b_1 + b_2 = a_1 + (a_2 - a_1),\\
>   a_3 &= b_1 + b_2 + b_3 = a_1 + (a_2 - a_1) + (a_3 - a_2).
> \end{aligned}
> $$

---

**🔹 性质二：区间加法优化（核心应用）**

- **目标：**  
  将原数组中区间 $[l, r]$ 内的所有元素增加常数 $c$。  

- **差分做法：**  
  只需在差分数组上执行两步，时间 $O(1)$：  

$$
\begin{cases}
  b_l \;+=\; c,\\
  b_{r+1} \;-\!=\; c.
\end{cases}
$$  

  这样，恢复原数组时，$$a_l,\dots,a_r$$ 全部增加 $c$，其它位置不变。

---

**具体证明**

1. 修改 $b_l += c$ 后：  
      - 对于 $i < l$，$b_1,\dots,b_{l-1}$ 都不变，故 $a_1,\dots,a_{l-1}$ 不变。  
      - 对于 $i \ge l$，$b_l$ 变为 $b_l + c$，恢复时从 $a_l$ 开始到末尾都多加 $c$。  

2. 再执行 $b_{r+1} -= c$：  
      - 对于 $i \le r$，已经每项多加 $c$，故 $a_l,\dots,a_r$ 正确加 $c$。  
      - 对于 $i \ge r+1$，在原本已加 $c$ 的基础上再减 $c$，恢复到原值。  

因此，只改 $b_l$ 和 $b_{r+1}$ 即可完成区间加操作。

---

**🔹 差分数组模板**

- **预处理差分数组**（若初始 $a$ 不全 $0$）：  
   ```cpp
   for (int i = 1; i <= n; i++) 
   {
       cin >> a[i];
       b[i] = a[i] - a[i - 1]; // 差分定义
   }
   ```
   > 若原数组全为 $0$，则可跳过预处理，直接操作 `b` 数组。

---


- **区间修改操作（将 `[x, y]` 范围内元素加 `z`）**：
```cpp
while (m--) 
{
    int x, y, z;
    cin >> x >> y >> z;
    b[x]     += z;
    b[y + 1] -= z;
}
```

- **还原原数组并求值**

- 方法一：通过前缀和还原 $a$，顺便求最小/最大等：
  ```cpp
  int ans = 1e9;
  for (int i = 1; i <= n; i++) 
  {
      b[i] += b[i - 1]; // 前缀和还原 a[i]
      ans = min(ans, b[i]);
  }
  ```
- 方法二：先恢复 `a[i] = a[i - 1] + b[i]`，在做其他运算：
  ```cpp
  int ans = 1e9;
  for (int i = 1; i <= n; i++) 
  {
      a[i] = a[i - 1] + b[i]; // 前缀和还原 a[i]
      ans = min(ans, a[i]);
  }
  ```

---

### 🔸 二维差分




### ✨ 等差数列差分

---

**🎯 前置知识：等差数列**

- **定义**：若一个数列从第二项起，每项与前一项的差都相同，则称为等差数列。该差值称为“公差” $d$。  
- **记法**：首项 $a_1$、末项 $a_n$、公差 $d$。  

**基本公式**：  
- 等差数列前 $n$ 项和：  
  $$
  S_n = \frac{(a_1 + a_n)\times n}{2}.
  $$
- 若已知 $a_l$ 与 $a_r$，则公差：  
  $$
  d = \frac{a_r - a_l}{r - l}.
  $$

---

**🔹 题意**

- 给定 $m$ 次操作，每次选择区间 $[l, r]$，使该区间内所有数字加上一个等差数列，首项为 $s$、末项为 $e$。  
- 由此可算出公差：  
  $$
  d = \frac{e - s}{r - l}.
  $$

---

**🔹 二次差分引入**

1. **一次差分**：  
   $$
   b_i = a_i - a_{i-1}.
   $$
2. **二次差分**：  
   $$
   c_i = b_i - b_{i-1}.
   $$
3. 当对区间 $[l, r]$ 增加等差数列时，只有少数几个位置的 $b$ 和 $c$ 会发生变化，具体如下：

---

**🔸 二次差分示意**

假设在 $[l, r]$ 区间加等差数列，首项 $s$、末项 $e$、公差 $d$。则：


| 下标             | $l - 1$ | $l$            | $l + 1$    | $\cdots$ | $r$         | $r + 1$         | $r + 2$       |
|:----------------:|:---------:|:----------------:|:------------:|:----------:|:-------------:|:-----------------:|:---------------:|
| **原数组 $a$ 增量** | 0         | $\color{red}{ s}$      | $\color{red}{s + d}$ | $\cdots$   | $\color{red}{e}$      | 0                 | 0               |
| **一次差分 $b$**   | 0         | $\color{red}{s }$      | $\color{red}{d}$      | $\cdots$   | $\color{red}{d}$      | $\color{red}{-e}$    | 0               |
| **二次差分 $c$**   | 0         | $\color{red}{s}$      | $\color{red}{d - s}$  | 0            | 0             | $\color{red}{-(e + d)}$ | $\color{red}{e}$     |

> **只需维护** $c_l, c_{l+1}, c_{r+1}, c_{r+2}$ 四个位置，恢复时做两次前缀和即可得到原数组 $a$。



---

**🔹 完整代码（1D 等差更新 + 二次差分）**

```cpp
// 读入 n, m 省略
// c[] 为二次差分数组，b[] 为一次差分数组，a[] 为原数组
while (m--) 
{
    int l, r, s, e;
    cin >> l >> r >> s >> e;
    long long d = (e - s) / (r - l); // 计算公差
    c[l]     += s;
    c[l + 1] += d - s;
    c[r + 1] += -(e + d);
    c[r + 2] += e;
}
// 恢复：先通过一次累加还原 b，再通过一次累加还原 a
for (int i = 1; i <= n; i++) 
{
    b[i] = b[i - 1] + c[i];    // 一次前缀和还原到 b
    a[i] = a[i - 1] + b[i];    // 二次前缀和还原到 a
}
```

⏱ 时间复杂度：$O(n+m)$。


## 📌 三、离散化

---

**🎯 核心概念**

> **什么是离散化？**  
> 将原来值域很大的数据，**映射到一个连续小范围内**，便于开数组、使用树状数组、线段树等。

- 作用：将稀疏的下标压缩成密集的小整数区间。

---

**🔹 离散化步骤**

1. **收集所有待离散化的坐标**  
   - 将每个操作或查询中出现的坐标值（如区间端点、查询点）都加入一个数组 `lsh` 中。

2. **排序并去重**  
   ```cpp
   sort(lsh.begin(), lsh.end());
   lsh.erase(unique(lsh.begin(), lsh.end()), lsh.end());
   ```
3. **二分查找映射**  
   对于任意原坐标 `x`，使用  
    ```cpp
    int idx = lower_bound(lsh.begin(), lsh.end(), x) - lsh.begin() + 1;
    ```




## ⭐️ 四、和式入门与技巧

---

**🎯 核心概念**



**什么是和式？**  

用 ∑ 表示“连续相加”的表达式，例如：  

$$
\sum_{i=1}^n i = 1 + 2 + 3 + \dots + n
$$  

嵌套示例：  

$$
\sum_{i=1}^n \sum_{j=1}^m a_{i,j}
$$

- 在算法竞赛中，和式常用来表示循环累加过程，简化版即化为公式计算。

---

**🔹 基本性质**

1. **可拆分（区间拆分）**  
   
$$
\begin{aligned}
&\sum_{i=1}^{n} a_i \\
=&\sum_{i=1}^{m} a_i+\sum_{i=m+1}^{n} a_i.
\end{aligned}
$$

2. **可分配（加法）**  

$$
\begin{aligned}
&\sum_{i=1}^{n} (a_i + b_i) 
=&\sum_{i=1}^{n} a_i +\sum_{i=1}^{n} b_i.
\end{aligned}
$$

3. **常数可提取**  
  
$$
\sum_{i=1}^{n} k \,a_i =k \sum_{i=1}^{n} a_i.
$$

---

**🔹 例题与化简技巧**

**例题 1 ：每个数被加了几次？**

- 设 $a_1, a_2, \dots, a_n$ 是一个数组。化简  

$$
\sum_{i=1}^n \sum_{j=i}^n a_i.
$$

- **观察**：内层和与 $j$ 相关，但 $a_i$ 不依赖 $j$，可提取：  

$$
\begin{aligned}
&\sum_{i=1}^n a_i \sum_{j=i}^n 1 \\
= &\sum_{i=1}^n a_i \cdot (n - i + 1).
\end{aligned}
$$

复杂度从 $O(n^2)$ 降为 $O(n)$。

---

**例题 2 ：嵌套求和**

- 化简  
  
$$
\sum_{i=1}^n \sum_{j=i}^n (a_i \times j).
$$

- 提取 $a_i$：  

$$
\begin{aligned}
&\sum_{i=1}^n a_i \sum_{j=i}^n j\\
=&\sum_{i=1}^n a_i \times \frac{(i + n)(n - i + 1)}{2}.
\end{aligned}
$$

---

**🔹 交换求和次序（重要技巧）**

- 交换前：  

$$
\sum_{i=1}^{n} \sum_{j=i}^{n} f(i, j).
$$

- 交换顺序：  

$$
= \sum_{j=1}^{n} \sum_{i=1}^{j} f(i, j).
$$

> ★ 有时交换顺序后更易化简。

---

**例题 3 ：换序简化**

- $\displaystyle \sum_{i=1}^n \sum_{j=1}^i j$  
- **交换前含义**：  
  $(1) + (1 + 2) + (1 + 2 + 3) + \cdots + (1 + 2 + \cdots + n)$.  
- **交换后**：  

$$
\sum_{j=1}^n \sum_{i=j}^n j = \sum_{j=1}^n j \cdot (n - j + 1).
$$

---

**例题 4 ：双重和式**

$$\begin{aligned}
        &\sum\limits_{i=1}^n \sum\limits_{j=i}^n a_i\times a_j\\ 
        =&\sum\limits_{j=1}^n \sum\limits_{i=1}^j a_i\times a_j\\
        =&\sum\limits_{j=1}^n a_j \sum\limits_{i=1}^j a_i\\
        =&\sum\limits_{j=1}^n a_j\times pre[j]
    \end{aligned}$$