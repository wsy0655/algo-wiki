
## ✨ 什么是递归？

**递归（Recursion）** 是一种解决问题的方法，它使得一个函数在定义时调用自己。

我们用一个经典的定义来说明：

> **递归定义**：当一个问题可以通过**更小规模的相同问题**来解决，并且存在一个明确的**终止条件**，这种方法就是递归。

---

## 🔁 递归的执行过程

可以这样理解：**递归是一种“不断分解问题”的过程**。

我们每次递归，都是把一个大问题，分解成一个更小的问题，然后继续解决更小的问题。

当问题被分解到最简单的情况（也就是我们设定的“终止条件”）时，我们就可以直接给出答案；然后再一步步返回每一层的答案。

### 类比：找人帮忙的故事

假设你要找出 $1 + 2 + \dots + 5$ 的和，但你不想一次做完。

于是你去问你的朋友：你能帮我算出 $1 + 2 + 3 + 4 + 5$ 的和吗？

他想了想，说：我不知道，但我可以问另一个人算 $1 + 2 + 3 + 4$ 的和，然后再加上 $5$。

这个人也去问别人，直到有一个人说：我知道 $1$ 的值是 $1$。

然后他告诉上面一个人答案是 $1$；上面那个人加上 $2$，变成 $3$，继续告诉上一个人。直到最开始问问题的人得到结果是 $15$。

这就是递归的执行方式：

* 一层一层地**向下拆解问题**（像递话一样传下去）
* 然后一层一层地**把答案传回来**（像传回话一样）



---

## 📦 递归函数的三要素

递归函数一般包括以下 **三要素**：

### 1. **终止条件（Base Case）**

必须要有！防止函数无限调用。

例如：

```cpp
if (n == 0) return;
```

### 2. **递归公式（递推关系）**

将大问题转化为小问题的表达式或逻辑。

例如：

$$
f(n) = f(n - 1) + f(n - 2)
$$

### 3. **递归调用（Self-call）**

函数自身调用自身，并逐步向终止条件靠近。

---

## 🛠️ 常见递归例题

### 例题1：返回 1 + 2 + … + n

```cpp
int sum(int n) 
{
    if (n == 1) return 1;
    return n + sum(n - 1);
}
```

### 例题2：返回 n!

```cpp
int factorial(int n) 
{
    if (n == 0 || n == 1) return 1;
    return n * factorial(n - 1);
}
```

### 例题3：返回第 n 个斐波那契数

```cpp
int fib(int n) 
{
    if (n == 1 || n == 2) return 1;
    return fib(n - 1) + fib(n - 2);
}
```

> 备注：第 n 个斐波那契数列：1, 1, 2, 3, 5, 8, 13, ...

---

## ⚠️ 递归算法的注意事项

* 避免无限递归，确保有 **Base Case**
* 避免重复计算（考虑转化为动态规划）
* 不要在递归中使用太多变量重复调用，除非有算法优化



