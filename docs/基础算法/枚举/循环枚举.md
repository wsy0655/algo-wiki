

## 算法简介

在算法竞赛中，枚举（Enumeration）是一种基础而直观的方法，通过遍历所有可能的解空间来寻找满足条件的答案。

虽然枚举的时间复杂度往往较高，但在约束较小或加入剪枝（Pruning）后，枚举依然是解决诸多组合问题的利器。

**示例场景**：

破解四位数字密码，可依次尝试 $0000\sim  9999$ 的所有组合；


---

## 循环枚举的基本思路

- **确定变量与范围**
   明确需要枚举的变量数量及各自取值区间。

- **设计嵌套循环**
   循环层数 = 变量个数，内层循环在外层每种取值下都要完整执行。

- **验证/计算**
   在最内层循环中，使用当前组合进行判断、计数或累加等操作。

- **剪枝优化（可选）**
   若部分组合可提前判定不符合条件，可在循环中加入 `if` 语句跳过后续无效枚举，以降低实际运行次数。

---

### 例题1：鸡兔同笼

> 已知鸡和兔共 $35$ 只，脚的总数为 $94$。求鸡和兔的数量。

**思路**：设鸡 $x$ 只，兔 $y$ 只，则

$$\begin{cases}
x + y = 35\\
2x + 4y = 94
\end{cases}$$

枚举 $x,y$，并判断 $x+y=35,2x+4y=94$ 是否成立。

- $x$ 的范围：$0 \leq x \leq 35$。
- $y$ 的范围：$0 \leq y \leq 35$。

因此需要两个循环嵌套枚举所有 $x$ 和 $y$ 的组合。


```cpp
for (int x = 0; x <= 35; x++) 
{
    for (int y = 0; y <= 35; y++) 
    {
        if (x + y == 35 && 2 * x + 4 * y == 94) 
        {
            cout << "鸡: " << x << ", 兔: " << y;
            return 0; // 找到解后退出
        }
    }
}
```

---

### 例题2：三位数回文数

> 找出所有三位数中正读和反读都相同的数字。

**思路**：三位数 $abc$ 是回文数当且仅当 $a = c$。

因此可以将所有的三位数 $100\sim 999$ 全部枚举出来，并判断百位和个位是否相等。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() 
{
    for (int i = 100; i < 1000; ++i) 
    {
        int a = i / 100; // 百位
        int b = (i / 10) % 10; // 十位
        int c = i % 10; // 个位
        if (a == c) // 判断回文
        { 
            cout << i << " ";
        }
    }
    return 0;
}
```

---


## 常见的枚举套路


### 区间枚举型

**示例问题一** 给定一个长度为 $n$ 的序列 $a$，求有多少个长度为 $k$ 的区间，满足区间和是偶数。

- $1\leq k\leq n\leq 1000$，$1\leq a_i\leq 10^9$。


**解题思路**

考虑枚举出所有的长度为 $k$ 的区间，并一一求和检验区间和是否为偶数即可。

对于一个长度为 $k$ 的区间，其左端点如果为 $i$，那么右端点 $j$ 则为 $i + k - 1$。

- 因此一旦确定左端点 $i$，右端点 $j$ 也就确定了。

所以枚举左端点 $i$：

- 左端点 $i$ 最小取值为 $1$，最大取值为 $n - k + 1$。

> 为何左端点的上限是 $n - k + 1$？
> 因为区间长度是 $k$，所以左端点不能超过 $n - k + 1$，否则右端点会超出边界。

```cpp
for (int i = 1; i <= n - k + 1; i++)
{
    int j = i + k - 1; // 右端点
    // 准备计算区间和
}
```

接下来计算区间 $[i,j]$ 的和，然后判断其是否为偶数即可。

时间复杂度：$O(nk)$


```cpp
int count = 0; // 计数器
for (int i = 1; i <= n - k + 1; i++)
{
    int j = i + k - 1; // 右端点
    long long sum = 0; // 初始化区间和
    for (int k = i; k <= j; k++) 
    {
        sum += a[k]; // 累加区间和
    }
    if (sum % 2 == 0) 
    {
        count++; // 如果区间和是偶数，计数器加一
    }
}
```

___

**示例问题二** 给定一个长度为 $n$ 的序列 $a$，求有多少个区间 $[l, r]$ 满足 区间的和 $a_l+a_l+...+a_r$ 是一个偶数。

- $n\leq 100$，$1\leq a_i\leq 10^9$。


**解题思路**

这是典型的区间枚举问题。可以枚举所有可能的区间 $[l, r]$，然后判断该区间的和是否为偶数。

一个区间靠左右端点的值来进行确定。

具体来说：

- 枚举左端点 $l$，从 $1$ 到 $n$。
- 枚举右端点 $r$，从 $l$ 到 $n$。
    - 右端点 $r$ 需满足 $\geq l$。
  
  ```cpp
  for (int l = 1; l <= n; l++) 
      for (int r = l; r <= n; r++) 
  ```

- 计算区间和 $a[l] + a[l+1] + ... + a[r]$。
    - 定义 $sum$ 初始化为 $0$。
    - 遍历区间 $[l,r]$，执行：$sum \leftarrow sum + a[i]$。
    - 判断 $sum$ 是否为偶数。
- 若 $sum$ 为偶数，则计数器加一。

时间复杂度：$O(n^3)$。

```cpp
for (int l = 1; l <= n; l++) 
{
    for (int r = l; r <= n; r++) 
    {
        int sum = 0; // 初始化区间和
        for (int i = l; i <= r; i++) 
        {
            sum += a[i]; // 累加区间和
        }
        if (sum % 2 == 0) 
        {
            count++; // 如果区间和是偶数，计数器加一
        }
    }
}
```


> 本题可以做到 $O(n)$ 感兴趣的同学可以自行研究。


___


### 矩阵枚举型

**示例问题** 给定一个 $n \times m$ 的矩阵，求有多少个 $a \times a$ 的子矩阵满其元素之和不超过 $k$。

其中 $1\leq a\leq n,m\leq 10^2$，$1\leq k\leq 10^9$，$1\leq a_{i,j}\leq 10^7$。


**解题思路**

这是一个典型的矩阵枚举问题。可以枚举所有可能的 $a \times a$ 子矩阵，然后判断该子矩阵的元素之和是否不超过 $k$。

一个 $a\times a$ 的子矩阵一旦确定了左上角的坐标，那么其右下角的坐标也就确定了。

因此确定左上角的坐标是关键所在。（当然反过来确定其他角的坐标也可以）


步骤如下：

1. **枚举左上角坐标**：枚举子矩阵的左上角坐标 $(i, j)$，其中 $1 \leq i \leq n - a + 1$，$1 \leq j \leq m - a + 1$。

> 为何左上角的上限是 $n - a + 1$ 和 $m - a + 1$？
> 因为子矩阵的大小是 $a \times a$，所以左上角的坐标不能超过 $n - a + 1$ 和 $m - a + 1$，否则子矩阵会超出边界。