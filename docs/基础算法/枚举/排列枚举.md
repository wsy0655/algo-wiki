


## 问题引入

给定 $n$ 个不同元素，需要枚举它们的所有排列顺序，并对每一种顺序执行某些操作（如计算路径长度、统计方案等）。

举例：有 $3$ 个城市 `A`、`B`、`C`，想要计算访问顺序的成本，需要枚举以下 $6$ 种路线：

$$\begin{cases}
A \to B \to C\\
A \to C \to B\\
B \to A \to C\\
B \to C \to A\\
C \to A \to B\\
C \to B \to A
\end{cases}$$


___

## 排列枚举

### 全排列的数量

根据乘法原理，第 $1$ 个位置有 $n$ 种选择，第 $2$ 个位置有 $n-1$ 种选择，$\cdots$，第 $n$ 个位置有 $1$ 种选择，
因此总的排列数为：

$$
n\times (n-1)\times (n-2)\times \cdots \times 1 = n!
$$


例如 $n=3$ 时共有 $3! = 6$ 种排列。

> 这揭示了枚举所有排列的复杂度非常之高。


___

### STL 专属函数：next_permutation

在 C++ 的 `<algorithm>` 头文件中，提供了 `next_permutation` 函数，用于生成当前序列的**下一个**字典序排列。

```cpp
bool next_permutation(BidirIt first, BidirIt last);
```

- **参数**  
    - `[first, last)`：双向迭代器区间 $[first, last)$，表示待排列的范围。
    - 注意是左闭右开，用法类似于 `sort` 函数。
- **返回值**  
    - 若存在 **下一个** 字典序排列，函数生成下一个排列并返回 `true`。  
    - 若已是最大字典序排列，则函数会将序列重置为最小排列，并返回 `false`。


___

**使用示例**


时间复杂度：$O(n!\times n)$

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int n;
    cin >> n;
    int a[15];
    for (int i = 1; i <= n; i++) a[i] = i; // 初始化为字典序最小的排列
    do 
    {
        for (int i = 1; i <= n; i++)
          cout << a[i] << " ";
        cout << "\n";
    } while (next_permutation(a + 1, a + n + 1));
    return 0;
}
```

- 首次执行循环时处理最小排列 $1\sim n$。  
- 每次调用 `next_permutation` 生成下一个排列，并决定是否继续循环。  

**`do - while` 循环要点**

- `do {...} while(condition);` 保证循环体至少执行一次。  
- 结合 `next_permutation`，可确保最初排列（最小字典序）也被处理。



## 例题