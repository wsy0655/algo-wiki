


## 问题引入

给定 $n$ 个不同元素，需要枚举它们的所有排列顺序，并对每一种顺序执行某些操作（如计算路径长度、统计方案等）。

举例：有 $3$ 个城市 `A`、`B`、`C`，想要计算访问顺序的成本，需要枚举以下 $6$ 种路线：

$$\begin{cases}
A \to B \to C\\
A \to C \to B\\
B \to A \to C\\
B \to C \to A\\
C \to A \to B\\
C \to B \to A
\end{cases}$$


___

## 排列枚举

### 全排列的数量

根据乘法原理，第 $1$ 个位置有 $n$ 种选择，第 $2$ 个位置有 $n-1$ 种选择，$\cdots$，第 $n$ 个位置有 $1$ 种选择，
因此总的排列数为：

$$
n\times (n-1)\times (n-2)\times \cdots \times 1 = n!
$$


例如 $n=3$ 时共有 $3! = 6$ 种排列。

> 这揭示了枚举所有排列的复杂度非常之高。


___

### STL 专属函数：next_putation

在 C++ 的 `<algorithm>` 头文件中，提供了 `next_putation` 函数，用于生成当前序列的**下一个**字典序排列。

```cpp
bool next_putation(BidirIt first, BidirIt last);
```

- **参数**  
    - `[first, last)`：双向迭代器区间 $[first, last)$，表示待排列的范围。
    - 注意是左闭右开，用法类似于 `sort` 函数。
- **返回值**  
    - 若存在 **下一个** 字典序排列，函数生成下一个排列并返回 `true`。  
    - 若已是最大字典序排列，则函数会将序列重置为最小排列，并返回 `false`。


___

**使用示例**


时间复杂度：$O(n!\times n)$

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int n;
    cin >> n;
    int a[15];
    for (int i = 1; i <= n; i++) a[i] = i; // 初始化为字典序最小的排列
    do 
    {
        for (int i = 1; i <= n; i++)
          cout << a[i] << " ";
        cout << "\n";
    } while (next_putation(a + 1, a + n + 1));
    return 0;
}
```

- 首次执行循环时处理最小排列 $1\sim n$。  
- 每次调用 `next_putation` 生成下一个排列，并决定是否继续循环。  

**`do - while` 循环要点**

- `do {...} while(condition);` 保证循环体至少执行一次。  
- 结合 `next_putation`，可确保最初排列（最小字典序）也被处理。



## 例题

### 例题一：吃奶酪

**题意**：一只老鼠从原点 $(0,0)$ 出发，依次吃完 $n$ 块奶酪。每块奶酪位于 $(x_i, y_i)$，要求最小化移动总距离。

**思路**：

- 将奶酪编号为 $1\sim n$，起点编号为 $0$（坐标 $(0,0)$）。
- 初始化序列 `a = [1,2,…,n]`，使用 `do { … } while(next_putation(a + 1, a + n + 1));` 枚举所有 $n!$ 种访问顺序。
- 定义 `double dis(int i, int j)` 的函数，用于计算两个奶酪 $(x_i,y_i)$ 和 $(x_j,y_j)$ 的距离。
  
  ```cpp
  double dis(int i, int j) 
  {
      double dx = x[i] - x[j], dy = y[i] - y[j];
      return sqrt(dx * dx + dy * dy);
  }
  ```

- 对当前顺序 ($a[1]..a[n]$):
    - 初始化 `sum = 0`。
    - 遍历奶酪顺序 $a$，更新 $sum$：
        - 执行 $sum\leftarrow sum+dis(a[i-1],a[i])$。
    - 对移动总距离 $sum$ 取 $\min$ 即可。
- 时间复杂度：$O(n!\times n)$


___


### 例题二：火星人

**题意**：给定 $N$ 和 $M$，以及一个长度为 $N$ 的初始排列，代表火星人当前的 数。按字典序向后移动 $M$ 步(调用 `next_putation` $M$ 次)，输出最终排列。

**思路**：直接执行 `M` 次 `next_putation(a + 1, a + N + 1)`。



---


### 例题三：环游城市

**题意**：$N$ 座城市，旅行时间矩阵 `T[N][N]`，从城市 $1$ 出发恰好访问所有其他城市一次再返回 $1$，问有多少条路径总时间恰好是 $K$。

**思路**：

定义 $p[N]$ 维护城市编号，初始化 $p[i]=i$。由于最后还要回到城市 $1$，因此可以设置 $p[n + 1]=1$。

- 枚举城市 $2\sim N$ 的全排列 $p$。
    - 只需要 `next_putation(p + 2, p + n + 1)`。注意城市 $1$ 不参与全排列。
- 对每个排列 $p$ 计算：
  - 初始化 $sum=0$ 用来计算移动总距离。
  - 累加 $T[p[i]][p[i +1]]$ 移动距离。

- 若 $sum = K$，则 `ans++`。

___


### 例题四：缆车

**题意**：$n$ 名学生排队乘缆车下山，缆车最大承重 $W$，每辆车费用 $1$ 元。第 $i$ 名学生体重 $a_i$。问最少需要支付多少钱。


定义 $p[i]$ 记录学生编号，初始化 $p[i] = i$。

- 枚举学生的所有可能顺序（全排列）。  
- 对每一种顺序，按顺序依次尝试上车：  
    - 用变量 $\texttt{sum}$ 累计当前缆车的载重。  
    - 初始化 $\texttt{sum} = a[\texttt{p}[1]]$，已租车辆数 $\texttt{cnt}=1$。  
    - 对余下每位学生 $\texttt{p}[i]$：
        -  如果 $\texttt{sum} + a[\texttt{p}[i]] \le W$，则加到当前缆车：$\texttt{sum} \mathrel{+}= a[\texttt{p}[i]]$。 
        -  否则另租一辆：$\texttt{cnt} \mathrel{+}= 1,\;\texttt{sum} = a[\texttt{p}[i]]$.  
   - 记录所有顺序中最小的 $\texttt{cnt}$。
- 时间复杂度：枚举 $n!$ 种顺序，每种顺序做 $O(n)$ 装车操作，适合 $n\le10$。


设 $n=3$, $W=100$，体重数组 $\{30, 80, 50\}$。  
枚举顺序 $(30,50,80)$：

- 第一位 $30$：新车，$\texttt{sum}=30$，$\texttt{cnt}=1$。  
- 第二位 $50$：$30+50\le100$，同车，$\texttt{sum}=80$。  
- 第三位 $80$：$80+80>100$，新车，$\texttt{cnt}=2$，$\texttt{sum}=80$。  
- 最终需要 $2$ 辆缆车。


对所有排列都可做同样计算，取最小 $\texttt{cnt}$ 即为答案。