


---

## 1️⃣ 整数之间的进制转换（整数部分） 🔁



### 十进制转其他进制（**除基取余法**）

**步骤**：对 $N$ 不断做

$$
N \div b = q,\quad r = N \bmod b,
$$

记录余数 $r$，然后令 $N \leftarrow q$；当 $N=0$ 时，把余数**逆序**拼回即为目标进制表示。

**示例（完整步骤）**：把 $123_{10}$ 转为二进制

$$
\begin{aligned}
123 \div 2 &= 61\ \ \ \mathrm{r}=1\\
61 \div 2  &= 30\ \ \ \mathrm{r}=1\\
30 \div 2  &= 15\ \ \ \mathrm{r}=0\\
15 \div 2  &= 7\ \ \ \mathrm{r}=1\\
7 \div 2   &= 3\ \ \ \mathrm{r}=1\\
3 \div 2   &= 1\ \ \ \mathrm{r}=1\\
1 \div 2   &= 0\ \ \ \mathrm{r}=1
\end{aligned}
\quad\Rightarrow\quad
123_{10}=1111011_2.
$$

**代码实现**

```cpp
// 十进制 n 转 b 进制的自定义函数
// 时间复杂度：O(logn) 
string f(int n, int b) 
{
	string s;
	while (n != 0)
	{
		int r = n % b;
		if (r < 10)
			s += char(r + 48); 
		else
			s += char(r + 55); 
		n = n / b; 
	}
	reverse(s.begin(), s.end());
	return s; 
}
```


---

### 其他进制转十进制（按位相加）



若一个数在进制 $b$ 下的位串为 $d_k d_{k-1}\dots d_1 d_0$，则它在十进制的值为

$$
N=\sum_{i=0}^{k} d_i\, b^i.
$$

把每位乘以其位权再相加。

---




**示例**：$\text{0x3F}$（十六进制）转换为十进制：

$$
\text{0x3F} = 3\times16 + 15 = 48 + 15 = 63.
$$


**代码实现如下**

```cpp
// b 进制的 s 转 10 进制的自定义函数
string f(string s, int b)
{
	long long sum = 0;
	for (int i = 0; i < s.size(); i++)
	{
		int d = 0;
		if (s[i] <= '9') 
			d = s[i] - 48;
		else
			d = s[i] - 55;
		sum = sum * b + d; 
	}
	return sum;
}
```

---


**例题题目**：把 $2025_{10}$ 转成二进制（写出完整结果）。📝

**解析**（逐步拆解）：

把 $2025$ 用 2 的幂拆分（写出从大到小的位权）：

$$
\begin{aligned}
2^{10} &= 1024,\\
2^{9}  &= 512,\\
2^{8}  &= 256,\\
2^{7}  &= 128,\\
2^{6}  &= 64,\\
2^{5}  &= 32,\\
2^{4}  &= 16,\\
2^{3}  &= 8,\\
2^{2}  &= 4,\\
2^{1}  &= 2,\\
2^{0}  &= 1.
\end{aligned}
$$

选取能相加到 $2025$ 的幂：

$$
2025 = 1024+512+256+128+64+32+8+1.
$$

对应位（从 $2^{10}$ 到 $2^0$）为：$1,1,1,1,1,1,0,1,0,0,1$，所以

$$
2025_{10}=11111101001_2.
$$

**答案**：$11111101001_2$ ✅

---


### 🔒 防伪开头：进制字面量标记法

在 C/C++ 里，不同进制的数有不同的写法：

- **二进制 bin**：前缀 `0b`。例如：`0b1001 = 9₁₀`
- **八进制 oct**：前缀 `0`。例如：`0123 = 83₁₀`（⚠️ 不是 $123$ 十进制！）
- **十进制 dec**：直接写数字。例如：`123 = 123₁₀`
- **十六进制 hex**：前缀 `0x`。例如：`0x3f = 63₁₀`

📌 **英文缩写对照**  

- bin（二进制）  
- oct（八进制）  
- hex（十六进制）  

**示例代码**：

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() 
{
    cout << 0b1001 << "\n"; // 二进制，9
    cout << 123     << "\n"; // 十进制，123
    cout << 0123    << "\n"; // 八进制，83
    cout << 0x3f    << "\n"; // 十六进制，63
}
```

## 2️⃣ 二 / 八 / 十六 之间的便捷转换 ⚡

> 目标：在考试中快速实现二进制与十六进制，二进制与八进制互转（不包括八进制与十六进制互转），不必每次先转到十进制。

### 核心规则（速记）

* 每一位十六进制（hex）对应 **$4$ 位二进制**：

  $$
  1\ \text{hex digit} \iff 4\ \text{binary bits}.
  $$

* 每一位八进制（oct）对应 **$3$ 位二进制**：

  $$
  1\ \text{octal digit} \iff 3\ \text{binary bits}.
  $$

**做法**：把二进制从低位向高位每 $4$ 或 $3$ 位分组，不足位在高位用 $0$ 补齐，然后逐组替换为 十六进制或八进制 的数字。


---


**练习 1**

把 $\text{0x7B}$ 转成二进制：

$$
7 = 0111,\quad B = 1011 \quad\Rightarrow\quad 01111011_2.
$$

通常去掉高位的前导 $0$，写作 $1111011_2$。

---

**练习 2**

把 $\text{0xA3F}$ 转为二进制和八进制。📝

**解析**：

* 先 十六进制转二进制：

  $A=1010,\quad 3=0011,\quad F=1111$
  
  所以

  $$
  \text{0xA3F} = 1010\ 0011\ 1111_2 = 101000111111_2.
  $$

* 二进制转八进制：从右向左每 $3$ 位分组（不足高位补 $0$）：

  $$
  101\ 000\ 111\ 111 \Rightarrow 5\ 0\ 7\ 7 \Rightarrow 5077_8.
  $$

**答案**：$101000111111_2,\quad 5077_8$ ✅

---

## 3️⃣ 小数部分的进制转换 🔢

### 二进制小数转十进制

例如二进制小数 $1010.01_2$ 转为十进制：

其转换规则同整数部分，区别仅仅在于需要累加小数部分的权重。即：


$$
1010.01_2=1\times 2^3+0\times 2^2+1\times 2^1+0\times 2^0+0\times 2^{-1}+1\times 2^{-2} = 10.25
$$

> $a^{-b}=\frac{1}{a^b}$

---


### 十进制小数转二进制

例如十进制小数 $0.25$ 转为二进制：

方法：乘 $2$ 取整法，直到小数部分为 $0$ 停下。

$$\begin{aligned}
0.25\times 2 &= 0.5\ \texttt{整数部分为}\ 0\\
0.5\times 2 &= 1.0\ \texttt{整数部分为}\ 1\\
\end{aligned}$$

小数部分为 $0$ 结束。

整数部分 **正序排列**。因此十进制小数 $0.25$ 的二进制为 $0.01_2$。

但有些十进制小数没有精确的二进制表示请看下面示例。

---

**示例（有限情况）**

把 $0.625_{10}$ 转为二进制：

$$
\begin{aligned}
0.625\times2 &= 1.25 \quad (a_1=1),\quad f=0.25\\
0.25\times2  &= 0.5 \quad (a_2=0),\quad f=0.5\\
0.5\times2   &= 1.0 \quad (a_3=1),\quad f=0
\end{aligned}
$$

因此 $0.625_{10}=0.101_2$（**有限**）。

---

**示例（循环情况）**

把 $0.1_{10}$ 转为二进制（前若干位）：

$$
\begin{aligned}
0.1\times2 &= 0.2\quad (0)\\
0.2\times2 &= 0.4\quad (0)\\
0.4\times2 &= 0.8\quad (0)\\
0.8\times2 &= 1.6\quad (1)\ \text{余 }0.6\\
0.6\times2 &= 1.2\quad (1)\ \text{余 }0.2\\
0.2\times2 &= 0.4\quad (0)\ \text{（重复）}
\end{aligned}
$$

得到循环节，前 $12$ 位为

$$
0.000110011001\ldots_2
$$

因此 $0.1_{10}$ 在二进制下是 **无限循环** 的。



---

## 4️⃣ 原码，反码，补码


在进行位运算前，我们需要理解计算机中数值的二进制表示方式：

**1. 原码（Sign-Magnitude）**

* 正数的原码就是其二进制形式。加一个符号位（最高位为 $0$）
* 负数的原码是其二进制，加一个符号位（最高位为 $1$）。

例如：

* `+1` 的原码：$\textcolor{red}00000000\ 0000000\ 00000000 \ 00000001$
* `-1` 的原码：$\textcolor{red}10000000\ 0000000\ 00000000 \ 00000001$

**2. 反码（Ones' Complement）**

* 正数的反码与原码相同。
* 负数的反码是对其原码除符号位外的每一位取反。

例如：

* `+1` 的反码：$\textcolor{red}00000000\ 00000000\ 00000000 \ 00000001$
* `-1` 的反码：$\textcolor{red}11111111\ 11111111\ 11111111 \ 11111110$

**3. 补码（Two's Complement）**

* 正数的补码仍与原码相同。
* 负数的补码 = 反码 $+ 1$。

例如：

* `+1` 的补码：$\textcolor{red}00000000\ 00000000\ 00000000 \ 00000001$
* `-1` 的补码：$\textcolor{red}11111111\ 11111111\ 11111111 \ 11111111$

计算机中 **所有数值的存储与计算** 都使用 **补码**。

---



## 4️⃣ 位运算 ⚙️



### 4.1 按位与：`&`

**定义**：对应位都为 $1$ 时结果位为 $1$，否则为 $0$。常用于**掩码**（取位）。

**性质**：

* $a\&b = b\&a$ （交换律）
* $a\&a=a$

**示例**：$5\&3$

$$
5=00000101_2,\quad 3=00000011_2\quad\Rightarrow\quad 00000001_2=1.
$$



---

### 4.2 按位或：`|`

**定义**：对应位任一为 $1$ 时结果位为 $1$。常用于**置位**。

**性质**：

* $a|b=b|a$
* $a|a=a$

**示例**：$5|2$
$5=00000101_2,\quad 2=00000010_2\ \Rightarrow\ 00000111_2=7.$



---

### 4.3 异或：`^`（XOR）

**定义**：对应位相异时为 $1$，相同时为 $0$。常用于**切换/无进位相加**。

**性质**：

* $x\oplus x = 0$
* $x\oplus 0 = x$
* 具有交换和结合律。

**示例**：$5^3$
$5=0101_2,\quad 3=0011_2\ \Rightarrow\ 0110_2=6.$


---

### 4.4 取反：`~`

**定义**：按位取反（0↔1）。在计算机中通常基于**二补码**，其数值关系为：

$$
\texttt{~x} = -x - 1\quad(\text{在有符号整型语义下}).
$$

**注意**：取反结果受**位宽**影响（例如 $8$ 位、$32$ 位等）。

**示例**（$8$-bit，无符号解释）：

$$
x=5\ (00000101_2)\ \Rightarrow\ \sim x=11111010_2 = 250\ (\text{unsigned}).
$$

**练习**

- **题**：在 8-bit 下，$x=150$，求 $\sim x$ 的**无符号**结果。
- **解**：$150=10010110_2$，取反得 $01101001_2=105$。
- **答**：$105$（无符号）。

---

### 4.5 左移：`<<`

**意义**：把位向左移动，低位补 $0$。在不溢出的情况下，等价于乘以 $2^k$：

$$
x<<k = x\times 2^k.
$$

**注意**：对负数或移位超出位宽，在 C/C++ 中可能 **未定义**。

**练习**

- **题**：$1<<3$ 等于多少？
- **答**：$8$（因 $1\times2^3=8$）。

> 通常使用 `1 << n` 快速获取 $2^n$。但要注意溢出问题。

---

### 4.6 右移：`>>`

**意义**：把位向右移动。对无符号数是逻辑右移（高位补 $0$），对有符号数很多实现做算术右移（高位补符号位），近似等价于整除 $2^k$：

$$
x>>k = \left\lfloor \frac{x}{2^k}\right\rfloor \quad (\text{对非负}~x).
$$

**注意**：带符号右移是否补符号位取决实现，不要在考试代码题中依赖未定义行为。

> 通常使用 `a + b >> 1` 代替 `(a + b) / 2`。


---


### 总结



所有的位运算计算都是用 **补码**  计算。

| 运算符 | 名称 | 描述                                                      | 示例（按位）                 |
| ------ | ---- | --------------------------------------------------------- | ---------------------------- |
| `&`    | 与   | 同为 $1$ 结果为 $1$                                       | `1101 & 1011=1001`           |       |              |
| `      | `    | 或                                                        | 有 $1$ 则为 $1$              | `1101 | 1011 = 1111` |
| `^`    | 异或 | 相同为 $0$ 不同为 $1$                                     | `1101 ^ 1011 = 0110`         |       |              |
| `~`    | 取反 | 所有位翻转                                                | `~1101 = 0010`（按位）       |       |              |
| `<<`   | 左移 | 所有位左移 $n$ 位，低位补 $0$                             | `0001 << 2 = 0100`           |       |              |
| `>>`   | 右移 | 所有位右移 $n$ 位，高位补符号位（有符号）或 $0$（无符号） | `1000 >> 2 = 0010`（无符号） |       |              |

---

## 5️⃣ 位运算常见技巧与应用 💡



### 技巧 A：取第 $i$ 位 —— `(n >> i) & 1`

**含义**：把第 $i$ 位右移到最低位，再与 $1$ 取与，得到 $0$ 或 $1$。



**示例**：令 $n=13$，求第 $2$ 位（从 $0$ 起计）：

- $13=1101_2,\quad (13>>2)=11_2=3,\quad 3\&1=1$，所以第 $2$ 位为 $1$。



---

### 技巧 B：取最低位的 1（lowbit） —— `x & -x`

**含义**：表达式 `x & -x` 返回 $x$ 中最低位的 $1$ 对应的 **值**（例如 $4$、$8$ 等）。

**原理**（直观）：在二补码下 $-x = \overline{x}+1$，与 $x$ 按位与只保留最低的 1。

**示例**：$x=12=1100_2$，则

$$
x\&(-x) = 1100_2 \& 0100_2 = 0100_2 = 4.
$$



---

### 技巧 C：清除最低的 1 —— `x & (x - 1)`

**含义**：表达式 `x & (x - 1)` 将把 $x$ 的最低位的 $1$ 变为 $0$，其余位不变。常用于计数二进制下 $1$ 的个数。

**例子**：$x=12=1100_2$，

$$
x\&(x-1) = 1100_2 \& 1011_2 = 1000_2 = 8.
$$

**应用**：计算 $\text{popcount}(x)$：

```cpp
int count(int x) // 求二进制下有几个 1
{
    int cnt = 0;
    while (x) 
    {
        x &= x - 1;
        ++cnt;
    }
    return cnt;
}
```


---

### 技巧 D：判断是否为 $2$ 的幂

**公式**：

$$
\text{isPow2}(x)\iff x>0\ \text{且}\ (x\& (x-1))==0.
$$

（因为 2 的幂在二进制中只有一个 $1$。）

**练习 D**

- **题**：$x=16$，判断是否为 2 的幂？
- **解**：$16\&(16-1)=16\&15=0$，且 $x>0$，所以是。
- **答**：是（$\text{True}$）。✅

---


### 技巧 E：统计 1 的个数（popcount）

**方法**：使用内置函数（如 GNU C++ 的 `__builtin_popcount(x)`）或循环 `x &= x - 1` 或直接数位拆分。


```cpp
int count(int x)
{
    int cnt = 0;
    while (x)
    {
        if (x % 2 == 1) cnt++;
        x /= 2;
    }
    return cnt;
}
```


---

